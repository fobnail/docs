{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is Fobnail Project?","text":"<p>Fobnail Project provides resources to create axiomatically trustworthy device and simple user interface to attest platform state. For a detailed project description, please check here.</p> <ul> <li>Fobnail firmware is an open-source implementation of the   iTurtle security architecture concept presented at HotSec07; in   addition, it will leverage industry standards like TCG D-RTM   trusted execution environment and IEFT RATS. The Fobnail project aims to   provide a reference architecture for building offline integrity measurement   verifiers on the USB device and attesters running in Dynamically Launched   Measured Environments (DLME). It allows the Fobnail owner to verify the   trustworthiness of the running system before performing any sensitive   operation. Fobnail does not need an Internet connection, which makes it immune   to the network stack and remote infrastructure attacks. It brings the power of   solid system integrity validation to the individual in a privacy-preserving   solution.</li> <li>The Fobnail Token is a tiny open-source hardware reference   design of a USB device that provides a means for a   user/administrator/enterprise to determine the integrity of a system. To make   this determination, Fobnail Token leverages Fobnail firmware,   which acts as an attestor capable of validating attestation assertions made by   the system. As an independent device, Fobnail Token provides a high degree of   assurance that an infected system cannot influence Fobnail Token as it   inspects the attestations made by the system.</li> </ul>"},{"location":"#where-to-go-next","title":"Where to go next?","text":"<ul> <li>Get familiar with Fobnail architecture</li> <li>Read Fobnail Project detailed description</li> <li>Building instructions</li> <li>How to support the project?</li> </ul>"},{"location":"#other-resources","title":"Other resources","text":"<ul> <li>TPM remote attestation over Bluetooth blog post by Gabriel   Kerneis, where he mentioned the Fobnail project.</li> </ul>"},{"location":"#where-to-buy","title":"Where to buy?","text":"<ul> <li>The Fobnail Token Development Kit can be ordered at the 3mdeb online store.</li> </ul>"},{"location":"architecture/","title":"Fobnail architecture","text":""},{"location":"architecture/#fobnail-components","title":"Fobnail components","text":"<p>See Remote Attestation Procedures Architecture for definitions of roles and artifacts mentioned below.</p>"},{"location":"architecture/#platform-owner","title":"Platform Owner","text":"<p>Takes roles of Verifier Owner and Relying Party Owner, as defined in RATS. Produces Appraisal Policies for Attestation Results and Evidence.</p> <p>During remote platform provisioning Platform Owner additionally proxies Reference Values, but Reference Value Provider role is still taken by the platform that is being provisioned.</p>"},{"location":"architecture/#fobnail-token","title":"Fobnail Token","text":"<p>Combines roles of Verifier and Relying Party. Consumes Evidence (from Attester), Reference Values (from Attester during local platform provisioning or from Platform Owner during remote platform provisioning), Endorsements (same as Reference Values, in form of EK certificate), Appraisal Policies (either installed by Platform Owner during remote platform provisioning or preinstalled default policy). Produces Attestation Result.</p>"},{"location":"architecture/#platform","title":"Platform","text":"<p>During platform provisioning, takes role of Reference Value Provider. It also relies Endorsements saved in TPM, but platform itself isn't an Endorser.</p> <p>During attestation, platform is an Attester - it collects Claims and produces an Evidence from it.</p>"},{"location":"architecture/#other-parties","title":"Other parties","text":"<p>The only missing role is that of an Endorser. Usually this is TPM manufacturer that installs EK certificate in TPM NVRAM.</p> <p>In cases when this certificate is not generated by TPM vendor, Endorsement must be created by another entity; this is outside of scope of Fobnail architecture.</p>"},{"location":"architecture/#fobnail-provisioning","title":"Fobnail provisioning","text":"<p>The purpose of provisioning is to provide a controlled process for an individual to take ownership and configure the Fobnail. During the provisioning process the token should provide the following information to the provisioner in the form of Certificate Signing Request (CSR):</p> <ul> <li>A public key to use for generating a certificate</li> <li>Metadata about the token, e.g. model, serial number, etc</li> </ul> <p>A token will consider itself provisioned when it is in an unprovisioned state and a provisioner sends it the certificate containing the public key the token generated. <code>keyUsage</code> field in that certificate depends on the actual use case, for example it may be used as an authentication certificate by platform when connecting with a server (e.g. SSH or mTLS). In that use case the platform doesn't know the private key, Fobnail Token performs the initial encryption during handshake.</p> <p>Either during provisioning or post provisioning a provisioner may send the following information,</p> <ul> <li>RIM Database</li> <li>Policy Database</li> <li>Attestation Protected Object</li> </ul> <p>This information must be signed by private key for the provisioner identity certificate contained in the provisioner Certificate Chain.</p>"},{"location":"architecture/#fobnail-provisioning-diagram","title":"Fobnail provisioning diagram","text":""},{"location":"architecture/#platform-provisioning","title":"Platform provisioning","text":"<p>Fobnail architecture consists of two main functionalities - provisioning and attestation. We need to provision a Fobnail token and platform. The platform provisioning is split into remote provisioning and local provisioning. During the remote provisioning, the platform can connect to the platform owner. The platform owner verifies the platform state and provides the RIM and attestation policies to the Fobnail token.</p>"},{"location":"architecture/#remote-platform-provisioning-diagram","title":"Remote platform provisioning diagram","text":"<p>In the case of local provisioning, the Fobnail token takes the platform owner role. The Fobnail token does not receive the policies, and default policies are used during the attestation.</p>"},{"location":"architecture/#local-platform-provisioning-diagram","title":"Local platform provisioning diagram","text":""},{"location":"architecture/#attestation","title":"Attestation","text":"<p>Fobnail role in the attestation of a system is to evaluate an Attestation Token and arrive at a decision whether the attested platform represents a good state. Fobnail is not an enforcement point for this decision and can only provide a physical and digital response to convey its decision. The physical response assumes that a user is monitoring the Fobnail Token and will take appropriate enforcement action(s). A digital response comes in the form of an Authorization Token that is returned back to the system. The assumption here is that the Authorization Token can securely be used by the system to enforce the decision or forwarded to an external entity that can enforce the decision.</p>"},{"location":"architecture/#attestation-diagram","title":"Attestation diagram","text":""},{"location":"architecture/#default-appraisal-policy","title":"Default appraisal policy","text":"<p>Appraisal policy controls what part of Evidence must match RIM, and what \"match\" means for a given element of RIM. Sometimes this is exact match (e.g. hash), for other data this may be value relation to reference value (e.g. component version same or newer than that from RIM).</p> <p>Default policy for Fobnail includes comparison of hashes of PCRs 0-7 and 17-18, for SHA256 bank. It is checked by using <code>TPM2_Quote()</code> command in order to avoid sending true PCR values through potentially insecure channel during attestation, so only hash of concatenation of those values can be intercepted during transit. In addition to PCR selection, Fobnail Token sends nonce that is included in signed response, which protects against replay attacks, and in combination with TPM mechanism against signing external data starting with magic number also proves that Claims and Evidence are fresh.</p> <p>Reasoning for choosing this particular set of PCRs is that PCR0-7 are used by pre-OS environment, and PCR17-18 are used in DRTM flow. Other registers are used by OS and may change after software is updated, which would require frequent re-provisioning of platform. SHA256 is the only algorithm commonly used - SHA1 is deprecated and SHA384, while mandatory according to latest TPM specification, is not implemented by majority of available TPMs.</p> <p>In addition to configurable part of policy described above, there are also implicit assumptions:</p> <ul> <li>Metadata is always checked - hash of metadata is used to generate filenames   for data stored in Fobnail Token.</li> <li>AIK (and because of its relation, also EK) doesn't change - it is saved during   platform provisioning and never again sent by the Attester. During attestation   Fobnail Token checks signatures of received data against this saved copy.</li> </ul>"},{"location":"blink-codes/","title":"Fobnail blink codes","text":"<p>One of the main advantages of using hardware dongle for attestation is that it can report the state to users without relying on proper functioning of PC (or another device) being attested. This is done by various blink codes representing different states of Fobnail Token operation.</p> <p></p> <p>Even though LED2 on nRF52840 dongle is a multicolor RGB LED, Fobnail only uses red in order to not exclude users with impaired color vision. LED1 is green. Unless noted otherwise, short blinks and intervals between blinks take 100 ms.</p>"},{"location":"blink-codes/#idle-states","title":"Idle states","text":""},{"location":"blink-codes/#token-not-provisioned","title":"Token not provisioned","text":"<p>Red LED will be lit indefinitely.</p>"},{"location":"blink-codes/#token-provisioned-waiting-for-coap-client","title":"Token provisioned, waiting for CoAP client","text":"<p>Both LEDs will shortly blink every 5 seconds. Cycle starts with blink, followed by a waiting period, so any LED failure should be visible when provisioned Token is connected to the device.</p>"},{"location":"blink-codes/#fobnail-provisioning","title":"Fobnail provisioning","text":"<p>On successful Token provisioning, green LED will blink once. No change on failure, i.e. red light will be kept on.</p>"},{"location":"blink-codes/#platform-provisioning","title":"Platform provisioning","text":"<p>On successful platform provisioning, green LED will blink three times, then Token goes back to waiting state. On failure no signal will be given, the Token will stay in waiting state and will keep blinking both LEDs every 5 seconds.</p>"},{"location":"blink-codes/#attestation","title":"Attestation","text":"<p>Note that Fobnail is exposed to OS as network device. As such, there may be multiple clients connected to it, even from another devices in local network, assuming proper (or improper, depending on use case) routing. One implication is that following states are not mutually exclusive, success and failure may be reported simultaneously.</p>"},{"location":"blink-codes/#success","title":"Success","text":"<p>Green LED will be lit as long as any successfully attested client is connected and has access to Fobnail Token Services. Client is considered disconnected after 3 seconds of inactivity.</p>"},{"location":"blink-codes/#failure","title":"Failure","text":"<p>Red LED will be lit for 5 seconds.</p>"},{"location":"building/","title":"Cloning and building","text":"<p>Fobnail project consists of 3 main repositories with code:</p> <ul> <li>Fobnail firmware (Rust)</li> <li>Platform Owner (C)</li> <li>Attester (C)</li> </ul> <p>There is also Fobnail SDK that simplifies building of firmware by using Docker container, but only one script from this repository is actually needed.</p> <p>Following steps were successfully performed on Ubuntu 22.04.1 LTS.</p>"},{"location":"building/#fobnail-token-firmware","title":"Fobnail Token firmware","text":"<p>Start by installing prerequisites:</p> <pre><code>sudo apt -y install git\n</code></pre> <p>Log out of the desktop session then log in again - this is required after making the change to user groups. You may confirm it by running <code>groups</code>.</p> <p>Clone the repository along with its submodules:</p> <pre><code>git clone https://github.com/fobnail/fobnail --recurse-submodules\n</code></pre> <p>Build process for Token firmware is by far the most complicated one. For that reason use of Fobnail SDK is strongly suggested. Follow these instructions to install it.</p> <p>With the SDK installed, one can prepare for the build process itself. Firmware can be build for a physical Fobnail Token or simulated on PC, with different preparatory steps required.</p> <p>If TPM simulator is to be used, steps from this document must be done before Token firmware is compiled. Instructions from the linked document result in creation of root CA certificate for EK chain, that certificate must be supplied as an input to Token build command. Physical TPMs require certificate provided by TPM vendor instead, those are included in <code>fobnail</code> repository.</p>"},{"location":"building/#environment-variables-common-for-both-targets","title":"Environment variables common for both targets","text":"<p>Fobnail Token firmware is configured with environment variables passed to <code>build.sh</code>.</p> <p>Note that due to the way Docker mounts directories all files and directories pointed to by following variables must be located somewhere in <code>fobnail</code> directory.</p> <ul> <li> <p><code>FOBNAIL_PO_ROOT</code> - required option, must point to valid PEM or DER file   with Platform Owner's root certificate. See this document   for description of PO certificate chain and instructions for building such.   For Fobnail Token firmware it is enough to create only root CA certificate.   The rest of chain will be required for provisioning.</p> </li> <li> <p><code>FOBNAIL_EK_ROOT_DIR</code> - points to directory with TPM root certificates.   Fobnail repository includes such directory   which normally should be used as <code>FOBNAIL_EK_ROOT_DIR</code>, but you may change it   if certificates supplied in repository became outdated. Either this or   <code>FOBNAIL_EXTRA_EK_ROOT</code> (or both) must be specified.</p> </li> <li> <p><code>FOBNAIL_EXTRA_EK_ROOT</code> - points to one specific TPM certificate. Useful when   testing with TPM emulator, or to limit Fobnail usage to   one specific TPM vendor. Either this or <code>FOBNAIL_EK_ROOT_DIR</code> (or both)   must be specified.</p> </li> </ul>"},{"location":"building/#building-and-running-firmware","title":"Building and running firmware","text":"Physical Fobnail TokenPC simulation <p>For hardware setup instructions see Flashing preparation.</p> <p>Building and flashing is performed by executing (from <code>fobnail</code> directory):</p> <pre><code>env FOBNAIL_PO_ROOT=root_ca.crt FOBNAIL_EK_ROOT_DIR=tpm_ek_roots \\\n    ./build.sh -t nrf --run\n</code></pre> <p>A console with Fobnail Token output will be displayed. It is not required for normal operation but can be useful for debugging. It can be closed with Ctrl-C at any point. After that, Token can be used without nRF52840-DK - just plug it wherever it's needed.</p> <p>Make sure you have the network set up properly. See Networking setup for instructions. For firmware to work properly you need the <code>fobnail0</code> network interface configured.</p> <p>To build and run firmware execute the following commands (from <code>fobnail</code> directory).</p> <pre><code>env FOBNAIL_LOG=info FOBNAIL_PO_ROOT=root_ca.crt \\\n    FOBNAIL_EK_ROOT_DIR=tpm_ek_roots ./build.sh -t pc --run\n</code></pre> <p><code>FOBNAIL_LOG</code> environment variable sets log level. The possible log levels are: <code>error</code>, <code>warning</code>, <code>info</code>, <code>debug</code>, <code>trace</code>. This variable is valid only for PC target.</p> <p>Another variable used only on PC is <code>FOBNAIL_DEVICE_ID</code> - on hardware we used FICR registers to create a device ID, this gives a way of configuring it for emulation. This variable is optional, without it an ID of 0 is used.</p> <p><code>build.sh</code> automatically starts Token emulation. It runs until it's terminated with Ctrl-C.</p>"},{"location":"building/#pc-applications","title":"PC applications","text":"<p>Platform Owner and Attester have similar set of prerequisites, listed below. Depending on use case, they may or may not be run on the same PC, so these steps may have to be repeated on different computers.</p> <pre><code>sudo apt -y install git make gcc autoconf automake pkg-config libtool libssl-dev\n</code></pre> <p>Both applications use libcoap with v3 API which isn't provided by main Linux distributions yet, so it has to be built from sources and installed:</p> <pre><code>git clone https://github.com/obgm/libcoap.git --recurse-submodules\ncd libcoap\ngit checkout release-4.3.0\n./autogen.sh &amp;&amp; \\\n./configure --exec-prefix=/usr --disable-tests --disable-documentation \\\n    --disable-manpages --enable-dtls --with-tinydtls --enable-fast-install &amp;&amp; \\\nmake &amp;&amp; sudo make install\n</code></pre>"},{"location":"building/#platform-owner","title":"Platform Owner","text":"<p>With prerequisites installed, building Platform Owner application is simple - just clone and build:</p> <pre><code>git clone https://github.com/fobnail/fobnail-platform-owner --recurse-submodules\ncd fobnail-platform-owner\nmake\n</code></pre> <p>Produced binary is located in <code>bin/fobnail-platform-owner</code>, from where it can be moved to <code>PATH</code> or just started from there.</p>"},{"location":"building/#attester","title":"Attester","text":"<p>Attester requires additional packages to talk with TPM and download TPM's certificate chain from Internet:</p> <pre><code>sudo apt -y install libtss2-dev libcurl4-openssl-dev\n</code></pre> <p>After that, building is simple:</p> <pre><code>git clone https://github.com/fobnail/fobnail-attester --recurse-submodules\ncd fobnail-attester\nmake\n</code></pre> <p>Two executables are produced in <code>bin</code> folder: <code>fobnail-attester</code> and <code>fobnail-attester-with-provisioning</code>. First one can be moved to <code>PATH</code> for easier use. The latter is expected to be run only once per Token, by an administrator in a controlled environment, and not for daily use, so it can be not installed to avoid confusion.</p>"},{"location":"building/#summary-and-next-steps","title":"Summary and next steps","text":"<p>Congratulations, you have built all of the components of Fobnail! From here you should proceed to Token provisioning guide.</p>"},{"location":"debugging/","title":"Debugging nRF52840 dongle","text":"<p>It is possible to debug the nRF82540 dongle wit ha JLink debugger. The dongle contains a depopulated JLink header and a 10 pads for connecting the ribbon needle connector or a straight ribbon.</p>"},{"location":"debugging/#prerequisites","title":"Prerequisites","text":"<p>For this purpose we will need:</p> <ul> <li>nRF82540 Development Kit (PCA10056)</li> <li>Needle 10-pin cable with ribbon 1.27mm pitch   for use with Development Kit</li> </ul> <p>One may use a JLink pro with a suitable adapter to the correct ribbon cable with needle connector. However JLink PRO is very expensive (25x more expensive than development kit).</p> <p>Also if using a development kit, it only uses a voltage o 3V to program and debug applications so we need to slightly modify the dongle for development kit use.</p> <ol> <li>Firstly cut the SB2 and solder SB1. This will allow to use VDD_OUT pin as a    power source.    </li> <li>Solder jumper wires (male-end) to the following pads (color convention may    be different, but in the whole documentation we will use the following color    convention):     Description:</li> <li>black wire - male-male jumper wire (GND)</li> <li>violet - male-male jumper wire (VDD_OUT)</li> </ol> <p>IMPORTANT! Do not connect the dongle to USB when SB2 is cut and SB1 is soldered.</p>"},{"location":"debugging/#connection","title":"Connection","text":"<p>How does it work? The nRF82540 development kit can program external chips via the <code>debug out</code> connector. In order to program the nRF52840 dongle:</p> <p></p> <ol> <li>Connect Needle 10-pin cable with ribbon 1.27mm pitch to the debug out    header. The ribbon has an edging which fits into the header only in one    orientation.</li> <li>Connect black write from the dongle to one of the red GND pin on the female    header on the left (according to picture). Connect the violet wire from the    dongle to the red VDD pin on the female header on the left (according to    picture). The development kit will source VDD power 3V which is suitable for    the programming with the development kit. The dongle automatically uses 5V    on the VDD and VBUS' (connected to EXT_GND_DETECT) which will damage the dev    kit. Also the dev kit selects which chip to program based on the power    supply of the target chip:</li> <li>if VDD is present on the debug out connector then the external chip is      programmed</li> <li>otherwise the dev kit's on-board chip is programmed    So in order to program the dongle with the dev kit we have to supply    compatible voltage from the dev kit to the dongle. That is why the dongle    required modifications to source power from VDD_OUT pin.</li> <li>Connect the needle 10-pin cable with ribbon 1.27mm pitch to the JLink    connector on the dongle (see picture below, marked in red). The needle has 3    positions pins which will fit in a single orientation only.    </li> </ol>"},{"location":"debugging/#programming-and-recovery","title":"Programming and recovery","text":"<p>Now that we have prepared correct connections between dev kit and the dongle we may proceed with flashing. For example if we erase whole chip along with UICR which sets the voltage regulator on the dongle we will not be able to program it via dev kit unless we do the modifications described before. The nRF52840 chip on the dongle hardware is configured in high voltage mode. This uses REG0 to lower the chip supply voltage (VDD), and the default value is 1.8 V, configured by the REGOUT0 register in UICR. This is too low to be used with the on-board programmer on the nRF52840 DK, so erasing or programming with a firmware that does not configure the regulator for a higher VDD will leave it in a state where it cannot be re-programmed from a dev kit.</p> <p>To avoid problems if you are using a debugger without level shifter (such as a nRF52840 DK):</p> <ul> <li>Avoid erasing the UICR of the chip (i.e. do not do a full chip erase).</li> <li>If you must erase the UICR, make sure that you do not reset the board until   after you have programmed either REGOUT0 directly or firmware that sets it.</li> <li>Alternatively, modify the dongle as explained under External regulated source   and supply the dongle directly from the nRF52 DK (assuming it is used as a   debugger).</li> </ul> <p>In our case we have done the modifications and will recover the original bootloader:</p> <ol> <li><code>wget https://devzone.nordicsemi.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-00-13/pca10059_5F00_bootloader.zip</code></li> <li><code>unzip pca10059_5F00_bootloader.zip</code></li> <li>Copy the file    <code>graviton_bootloader_mbr_v1.0.1-[nRF5_SDK_15.0.1-1.alpha_f76d012].hex</code> into    the directory mounted inside thee fobnail-sdk container.</li> <li>Grab the dongle with needle and hold it tight so that the needle will    connect with the pins.</li> <li>Execute <code>nrfjprog -f NRF52 --program graviton_bootloader_mbr_v1.0.1-[nRF5_SDK_15.0.1-1.alpha_f76d012].hex --chiperase</code></li> <li>Disconnect the needle and the wires from dongle and devkit.</li> <li>Connect violet and green wire.</li> <li>Plug the dongle into computer USB port while holding reset button. Check if    the LED diode is blinking red which indicates teh original bootloader mode    has been entered. Also the <code>dmesg</code> that the USB Nordic bootloader has been    detected.</li> </ol>"},{"location":"debugging/#debugging","title":"Debugging","text":"<p>There is an incompatibility in the debug header of the dongle and dev kit:</p> <p> </p> <p>The 5th pin of debug out header (second picture) is connected the the dev kit's ground, while 5th pin on the JLink header on the dongle is connected to VBUS' which is 5V when the dongle is connected to the USB. This makes the debugging of the dongle effectively impossible when the dongle is connected to the USB port. However, when it is supplied with power via VDD_OUT, it is possible to debug it, but it will be impossible to debug USB connection. The right way to debug the dongle without modifications is to use the P1 header on the dongle which matches 100% the pinout of debug out header of the dev kit. Note that the modifications are still needed if the UICR is removed to supply the VDD of the dongle with 3V from dev kit.</p> <p>In order to connect to the P1 header one would need a SMT 2x5 pin header pitch 1.27mm, the same as used on the debug out header on the dev kit. Here you may find big pictures of such header: https://blog.adafruit.com/2019/01/17/new-product-mini-swd-0-05-pitch-connector-10-pin-smt-box-header/</p> <p>Until we do not need to debug USB connection, we may use a blinky sample as a reference program to be debugged. Refer to Flashing sample applications how to build the samples. Now we will try to flash them with the needle connector instead of USB DFU. Inside the fobnail SDK container execute:</p> <ol> <li><code>make clean</code></li> <li><code>make mcuboot_demo</code></li> <li><code>make blinky_demo</code></li> <li>Ensure the chip is erased (ti simulate a fault and that we lost UICR) so    connect the black and violet wires to the dev kit's GND and VDD, grab the    dongle with needle and hold it tight so that the needle will connect with    the pins. Execute <code>make erase</code>.</li> <li>Flash the nRF52840 dongle while holding the needle:    <pre><code>nrfjprog -f NRF52 --program graviton_bootloader_mbr_v1.0.1-\\[nRF5_SDK_15.0.1-1.alpha_f76d012\\].hex\n</code></pre></li> <li>Unplug and plug the violet wire to dev kit's VDD. This will initiate a reset    of the dongle (the Jlink header does not expose reset signal, only P1 header    has reset signal).</li> <li>Notice the red LED should start blinking indicating Nordic's bootloader    mode. It has entered the bootloader mode automatically because USB    connection has not been detected thus the rest switch was not needed.</li> <li>Solder SB2 and desolder SB1. Unplug black and violet wires. Unplug the    needle connector. Black wire floating safely.</li> <li>Plug the dongle into USB and flash the samples using DFU as instructed in    Flashing sample applications.</li> </ol> <p>Since the Nordic's bootloader is stuck when not connected to USB, and we cannot use dev kit to debug when dongle is connected to USB, the guide below presents how to debug a blinky sample on the nRF82540 chip present on the dev kit. Although it will apply to the dongle as well if you solder the P1 header and connect the straight ribbon cable to debug out and P1 header. If you have a straight ribbon cable and P1 header soldered you may use the dongle instead.</p> <ol> <li>Disconnect the dongle from the dev kit.</li> <li><code>west build -b nrf52840dk_nrf52840 -d build/blinky zephyr/samples/basic/blinky</code></li> <li><code>nrfjprog --eraseall -f nrf52</code></li> <li><code>nrfjprog -f nrf52 --program build/blinky/zephyr/zephyr.hex</code></li> <li>Now the green LED1 on the dev kit should start blinking.</li> <li>Launch JLink GDB server inside the container:    <pre><code>JLinkGDBServerCLExe -select USB -device nRF52840_xxAA -endian little \\\n    -if SWD -speed 4000 -ir -noLocalhostOnly &amp;\n</code></pre></li> <li>Connect with GDB to the nRF52840 chip on the dev kit:    <pre><code>gdb\n(gdb) file build/blinky/zephyr/zephyr.elf\n(gdb) target remote localhost:2331\n</code></pre></li> <li>Execute the following commands in GDB to start debugging [TBD]</li> </ol>"},{"location":"description/","title":"Fobnail Project detailed description","text":"<p>The Fobnail Project is an implementation of the iTurtle.</p> <p>The iTurtle concept presents a portable device that is a security USB stick, which provides platform trustworthiness checks. The result of the integrity check must be presented in an easy, visible way - for example, with the LED. We (3mdeb) want to provide the open-source reference implementation of the iTurtle device.</p> <p>Our goal is to create a scalable, flexible implementation that will be the core building block for future security solutions (created by the community) based on DRTM payloads. The Fobnail architecture concept is based on the IEFT specification - Remote ATtestation ProcedureS (RATS).</p> <p>The architecture supports Fobnail Token provisioning, remote and local Platform (Attester) provisioning, and attestation. Currently, there is no open source implementation of the USB attestation device.</p> <p>During the Fobnail Token provisioning, the Platform Owner creates the identity and encryption certificates that are used by the Attester to the Fobnail Token verification. The Fobnail Token verifies the Platform Owner certificate chain and generates the identity and encryption key pair. The Fobnail Token obtains the metadata (CPU serial) and conveys the encrypted public key parts and metadata to the Platform Owner. The received data is decrypted, and the Platform Owner creates identity and encryption certificates that are provided to the Fobnail Token.</p> <p>The Platform provisioning is split into remote provisioning (which is out of NLNet grant application scope) and local provisioning. In the case of local provisioning, the Fobnail Token takes the Platform Owner role. The Fobnail Token receives the Attester metadata (CPU serial, MAC, and EK certificate checksum) and generates the checksum. The metadata checksum is used for the Platform verification during the attestation. The Fobnail Token uses default policies during the local attestation.</p> <p>The attestation architecture is based on the Reference Interaction Model for Challenge-Response-based Remote Attestation (CHARRA). This is the IEFT attestation standard, which specifies the communication between the Attester and the Verifier (Fobnail Token). The Fobnail Token provides the ability to perform attestation in the absence of any connectivity. During the attestation development, we will use the proof-of-concept CHARRA implementation of the proposed architecture, which is developed by the Fraunhofer Institute.</p> <p>To demonstrate the capabilities of the implemented solution, we will create the example use case that uses the TrenchBoot, of which a significant part of AMD support was sponsored by NLNet as OpenDRTM, to verify the integrity of the system firmware, D-RTM Configuration Environment (DCE), Linux Kernel, and initrd.</p> <p>The main use case that will be presented as a demonstration is boot time attestation. The Fobnail Token will be used to verify an operating system during boot time. We will run inside DLME (Dynamically Launched Measured Environment) the Zephyr RTOS, which will check if the measurements of the operating system meet the reference measurements in the Fobnail Token. If the OS is compromised, the Fobnail Token warns the user, and Zephyr RTOS prevents a platform from booting.</p> <p>The Fobnail Project has the potential to scale up in the future. The Fobnail architecture could be adapted for devices using different buses than USB. We would like to implement another DRTM-based use case (that is out of the scope of this grant application), for example, runtime OS attestation. The Fobnail could be used to check if the runtime state of the platform is trusted. It could be based on one of the existing projects, such as Linux Kernel Runtime Guard. It could be useful to check the integrity of the Linux Kernel before performing sensitive operations.</p>"},{"location":"ek_certificates/","title":"Research of EK certificate chain sizes","text":"<p>This document combines results gathered from this issue. It was created to set expectations about size of data that has to be sent to and parsed by Fobnail Token.</p>"},{"location":"ek_certificates/#slb-9665tt20-tpm","title":"SLB 9665TT2.0 TPM","text":"<p>Used on PC Engines apu platforms:</p> <pre><code>Certificate 0 size: 1177 bytes\nCertificate 1 size: 1463 bytes\nCertificate 2 size: 1455 bytes\nCertificate is self-signed, assuming it is root\n\nChain length: 3\nTotal chain size: 4095 bytes\nSize of the biggest certificate: 1463 bytes\n</code></pre>"},{"location":"ek_certificates/#slb-9670-raspberry-pi","title":"SLB 9670 - Raspberry Pi","text":"<p>Two different specimens had slightly different chains:</p> <pre><code>Certificate 0 size: 1422 bytes\nCertificate 1 size: 1705 bytes\nCertificate 2 size: 1455 bytes\nCertificate is self-signed, assuming it is root\n\nChain length: 3\nTotal chain size: 4582 bytes\nSize of the biggest certificate: 1705 bytes\n</code></pre> <pre><code>Certificate 0 size: 1171 bytes\nCertificate 1 size: 1449 bytes\nCertificate 2 size: 1455 bytes\nCertificate is self-signed, assuming it is root\n\nChain length: 3\nTotal chain size: 4075 bytes\nSize of the biggest certificate: 1455 bytes\n</code></pre>"},{"location":"ek_certificates/#slb-9670-other-platforms","title":"SLB 9670 - other platforms","text":"<p>Found on multiple different platforms:</p> <ul> <li>NovaCustom NV4x</li> <li>NovaCustom NS5x/7x</li> <li>Protectli VP4630/50/70</li> </ul> <p>All tested samples had identical sizes, but it is possible that other chains exist, given that the same TPM model on Raspberry Pi had two different chains.</p> <pre><code>Certificate 0 size: 1171 bytes\nCertificate 1 size: 1449 bytes\nCertificate 2 size: 1455 bytes\nCertificate is self-signed, assuming it is root\n\nChain length: 3\nTotal chain size: 4075 bytes\nSize of the biggest certificate: 1455 bytes\n</code></pre>"},{"location":"ek_certificates/#unknown-tpm","title":"Unknown TPM","text":"<p>Reported by 0xDen</p> <pre><code>Certificate 0 size: 1184 bytes\nCertificate 1 size: 1463 bytes\nCertificate 2 size: 1455 bytes\nCertificate is self-signed, assuming it is root\n\nChain length: 3\nTotal chain size: 4102 bytes\nSize of the biggest certificate: 1463 bytes\n</code></pre>"},{"location":"ek_certificates/#ftpm-found-in-amd-processors","title":"fTPM found in AMD processors","text":"<p>These TPMs don't have EK certificates.</p>"},{"location":"ek_certificates/#summary","title":"Summary","text":"<p>All encountered EK certificate chains have the same length - 3 certificates including EK and root. Total size of chain oscillates around 4KB. Certificate sizes are similar across all collected data, with EK being slightly smaller than root and intermediate certificates. Biggest certificate in chain usually has around 1460 bytes, but there was one TPM with significantly larger maximal size of certificate - 1705 bytes.</p>"},{"location":"eth-over-usb-research/","title":"Ethernet over USB research","text":""},{"location":"eth-over-usb-research/#protocol-research","title":"Protocol research","text":"<p>There are 4 protocols implementing Ethernet-over-USB:</p> <ul> <li>RNDIS - Microsoft's proprietary protocol, not covered here as there are open   alternatives</li> <li>ECM - Ethernet Control Module</li> <li>EEM - Ethernet Emulation Model</li> <li>NCM - Network Control Model</li> </ul> <p>ECM, EEM and NCM protocols are USB-IF managed open standards (part of USB CDC).</p> <p>ECM is the oldest one, and according to Wikipedia article the simplest protocol of these three, its main advantage is simplicity - it has 2 communication channels: first channel is used for transferring   control messages like link status, etc. - requires 3 endpoints: 1 for control transfers, 1 bulk in, and 1 bulk out - second channel is used for sending raw, unmangled Ethernet frames.</p> <p>The main disadvantage of this protocol is its poor performance, maximum packet size is 64 bytes, Ethernet packets larger than that require few USB transfers. Every Ethernet frame must be sent in a single USB transfer (1 USB transfer may consist of many packets), it is not possible to bundle many Ethernet frames into one USB transfer.</p> <p>EEM protocol improves performance while still being relatively simple. EEM brings following improvements - no more 64 byte limit, can have any max packet size (usually 512 bytes for   USB 2.0) - small Ethernet frames may be packed into a single USB packet, thus improving   performance - CDC EEM 1.0 Specification, section 2 - Management Overview</p> <p>Unlike CDC ECM, EEM does not extend an interface across the USB bus but instead considers the USB bus to be a vehicle for moving Ethernet packets. - designed for local-only connection over USB emulated Ethernet,   where ECM is designed for connecting to a real network over Ethernet-to-USB   modem. - Requires only 2 endpoints (bulk in and bulk out)</p> <p>NCM is the latest protocol designed for high throughput, like ECM it is designed to control hardware with a real, physical Ethernet link, it is designed for controlling modern, complex hardware, thus protocol itself is very complex.</p> <p>I consider EEM protocol to be the best choice - it is designed for what we need - emulated Ethernet with no physical layer - better performance than ECM - ability to pack multiple Ethernet frames into one USB transfer reduces the   amount of time the driver needs to spend handling interrupts, thus offloading   CPU - EMM requires only 2 endpoints, so more endpoints are available for other   potential protocols we may implement in the future</p>"},{"location":"eth-over-usb-research/#ethernet-implementation-in-software","title":"Ethernet implementation in software","text":"<p>USB driver for NRF52 is already provided by nrf-hal project.</p> <p>Implementations of EEM protocol exist, but these are mostly written in C. I haven't found a single Rust implementation of EEM protocol (nor ECM), so a custom implementation is needed.</p> <p>Besides the EEM driver, we need an actual Ethernet driver, additionally we may need IP + UDP support for CoAP protocol, this may not necessarily be a requirement as CoAP protocol (used by CHARRA) doesn't seem to depend on UDP or any other transport layer, yet implementations do depend and removing that dependence could require more work than getting UDP support.</p> <p>There is one particularly interesting project called smoltcp, it is a library providing implementation of TCP/IP stack. These are the most important features: - provides support for IP + TCP + UDP and others - support for individual protocols may be disabled at compile time so we can   remove unneeded features like TCP (we can rely on UDP since USB already   provides reliable transmission) - no unsafe code inside library</p> <p>Looks like this is the only TCP/IP stack written in Rust and compatible with <code>no_std</code> environments.</p>"},{"location":"flashing_preparation/","title":"Flashing sample applications","text":""},{"location":"flashing_preparation/#required-hardware","title":"Required hardware","text":"<p>You need following hardware to flash apps:</p> <ul> <li> <p>nRF52840 dongle -   this is the target device on which Fobnail firmware runs.</p> </li> <li> <p>nRF52840-DK -   development board used for dongle flashing and debugging.</p> </li> <li> <p>SWD Cable - 2x5 1.27 mm pitch IDC   cable used for connecting dongle to debugger.</p> </li> <li> <p>Adafruit 4048 header - nRF dongle   comes without SWD header, so it must be soldered. This is the same header as   used in nRF52840-DK board.</p> </li> </ul> <p>When soldered, 4048 header's notch must face direction opposite to USB plug.</p> <p></p>"},{"location":"flashing_preparation/#preparing-debugger","title":"Preparing debugger","text":"<p>We use <code>cargo-embed</code> for firmware flashing and debugging, which internally uses <code>probe-rs</code>, so you need a compatible debugger. We are using nRF52840-DK development board, which exposes a JLink-compatible interface. To check whether your debugger is supported, connect the development kit to your PC with USB cable, start Fobnail SDK and run <code>probe-rs-cli list</code>. You will see output similar to this:</p> <pre><code>The following devices were found:\n[0]: J-Link (J-Link) (VID: 1366, PID: 1015, Serial: 000683081460, JLink)\n</code></pre> <p>If <code>probe-rs</code> does not detect debugger, that could mean it is not supported. You can set <code>RUST_LOG=trace</code> environment variable to retry scanning with debug output enabled.</p> <p>For debugger to work, you need to add an Udev rule granting you correct permissions:</p> <pre><code>SUBSYSTEM==\"usb\", ATTR{idVendor}==\"1366\", ATTR{idProduct}==\"1015\", OWNER=\"akowalski\", MODE=\"0660\"\n</code></pre> <p>Replace <code>idVendor</code> and <code>idProduct</code> and <code>OWNER</code> with correct VID, PID and your user name, save this to <code>/etc/udev/rules.d/99-usb.rules</code>, then run <code>sudo systemctl reload systemd-udevd</code> to apply these rules without rebooting.</p>"},{"location":"flashing_preparation/#optional-building-and-flashing-blinky-sample","title":"(Optional) Building and flashing blinky sample","text":"<p>In order to flash a sample application on the nRF52840 dongle we will use blinky sample application from our nrf-hal fork. Follow the steps below to build and flash blinky sample:</p> <ol> <li>Power on dongle and connect it to debugger.</li> <li>Go to <code>nrf-hal</code> directory</li> <li>Run the fobnail-sdk container with <code>run-fobnail-sdk.sh</code>.</li> <li>Go to <code>examples/blinky-demo-nrf52840</code></li> <li>Execute <code>cargo embed --target thumbv7em-none-eabihf</code>. This command will build    the sample app, flash it onto target device and spawn RTT console (sort of    UART-over-JTAG).</li> <li>Both green and red LEDs should start blinking, you should see RTT console    with similar message:    <pre><code>10:31:50.887 Blinky demo starting\n</code></pre></li> </ol>"},{"location":"flashing_preparation/#summary","title":"Summary","text":"<p>Cargo-embed provides great tools with very comfortable single-command solution for building and testing firmware.</p>"},{"location":"fobnail-api/","title":"Fobnail API","text":"<p>Fobnail Token exposes API over CoAP server exposed over UDP.</p>"},{"location":"fobnail-api/#general-considerations","title":"General considerations","text":"<p>This document describes API (major) version 1, and all API endpoint addresses are relative to (starting with) <code>/api/v1</code>. The version will be increased only when backward-incompatible changes are done.</p>"},{"location":"fobnail-api/#general-request-handling-rules","title":"General request handling rules","text":"<p>Some APIs create temporary objects that live at most as long as the client is connected. To check connection status, the server issues CoAP Ping requests, which clients must respond to in order to avoid losing their objects.</p> <p>When an object is created, the server responds with 2.01, <code>Location-Path</code> specifying the resource's path (a numeric object ID). Object IDs are specific to a client - a client cannot access object IDs of other clients. <code>Location-Path</code> is a string option, whereas object ID is an integer, so it must be encoded as a string. Object IDs may be passed as part of the CBOR payload (as an integer) or in URI (as a string).</p> <p>If the <code>Content-Format</code> option is not present, Fobnail Token assumes that <code>Content-Format</code> is <code>application/octet-stream</code>. All requests which pass CBOR-encoded data must set <code>Content-Format</code> option to <code>application/cbor</code> for Fobnail Token to interpret the payload as CBOR. The server responds with 4.00 (Bad Request) if unknown or invalid <code>Content-Format</code> is given. If passing CBOR-encoded data which is improperly encoded or not valid (e.g., required fields missing) server responds with 4.00. Passing <code>application/cbor</code> to an endpoint that expects <code>application/octet-stream</code> is invalid and will result in a 4.00 response.</p> <p>The client may send one or more <code>Accept</code> options which must be handled by the server. If the server can not respond in the format requested by the <code>Accept</code> options, it must respond with 4.06 (Not Acceptable).</p> <p>Conditional Request Options are not supported and will result in 4.02 (Bad Option). The payload should contain a human-readable message describing what options are not supported. See RFC7252 section 5.4.1 for details.</p> <p>Each response from the Fobnail Token must contain the <code>Content-Format</code> option unless it is an error response with a diagnostic payload. See RFC7252 for details.</p>"},{"location":"fobnail-api/#error-responses","title":"Error responses","text":"<p>Fobnail Token may return error codes as defined by the CoAP specification. An error response may contain an additional context sent as a payload. All cacheable error responses must have <code>Max-Age</code> set to 0.</p> <p>Error response must not contain the <code>Content-Format</code> option. Message (if present) must be passed as a raw UTF-8 string.</p>"},{"location":"fobnail-api/#fobnail-data-format","title":"Fobnail Data format","text":"<p>Fobnail uses CBOR (with a few exceptions) to transmit structured data from Fobnail to Attester and from Attester to Fobnail. We use a subset of RFC7049 (no tagging and no extensions).</p> <p>Clients are required to set <code>Content-Format</code> to <code>application/cbor</code> when transmitting CBOR-encoded data.</p>"},{"location":"fobnail-api/#data-signing","title":"Data signing","text":"<p>A signature is generated by taking an already CBOR-encoded object, a nonce (generated by Fobnail), and signing the hash of both of them. The nonce is appended to the CBOR blob as plain bytes. The resulting signature and original data (without nonce) are wrapped into another CBOR object:</p> <pre><code>{\n    // The data we signed (nested CBOR, without nonce)\n    // major 2 (byte array)\n    \"data\": [0x42, ...],\n    // The signature we just computed (major 2, byte array)\n    \"signature\": [0x20, ...]\n}\n</code></pre> <p>To obtain nonce for data signing, please use the /nonce endpoint.</p>"},{"location":"fobnail-api/#exception","title":"Exception","text":"<p>Request for <code>/attest/{id}</code> command has nonce explicitly included in sent structure. No additional data is appended before signing. Sent CBOR object has the same format as above. This (along with other mechanisms) ensures freshness of Claims, in addition to freshness of Evidence (see RATS architecture for description of those artifacts).</p>"},{"location":"fobnail-api/#api-endpoints","title":"API endpoints","text":"<p>Please note that all addresses listed below are relative to <code>/api/v1</code>, except the <code>/api/version</code> endpoint which is used to query supported API versions. To query supported API versions, please issue GET request to <code>/api/v1</code>. Server responds with 2.05 code and CoAP payload contains CBOR-encoded message:</p> <pre><code>{\n    // Array of supported API versions (major 4)\n    \"versions\": [\n        // API version 1 (major 0)\n        1,\n        // API version 2 (major 0)\n        2,\n        // API version 3 (major 0)\n        3,\n    ],\n}\n</code></pre>"},{"location":"fobnail-api/#uncategorized-endpoints","title":"Uncategorized endpoints","text":"Endpoint Name Method Arguments /nonce GET None"},{"location":"fobnail-api/#nonce","title":"/nonce","text":"<p>This endpoint is used to receive the nonce to be used for data signing. When called, Fobnail Token generates new nonce and responds with 2.05. Payload contains nonce as a raw byte array (currently 32 bytes).</p> <p>Nonce is bound to each client and is valid until it is used. When used, the client must call <code>/nonce</code> again to obtain a new nonce.</p> <p>Some requests return a new nonce as part of their response That's the case with the <code>/attest</code> endpoint and client must use nonce from <code>/attest</code> response in call to <code>/attest/{id}</code>. Attempt to call <code>/nonce</code> endpoint will invalidate Attestation Context.</p>"},{"location":"fobnail-api/#fobnail-token-provisioning","title":"Fobnail Token provisioning","text":"Endpoint Name Method Arguments /admin/token_provision POST PO certificate chain /admin/provision_complete POST Fobnail Identity/Encryption certificate <p>These APIs may only be executed when Fobnail Token is in an unprovisioned state. Fobnail Token must respond with 4.03 if these APIs are called after provisioning is complete.</p>"},{"location":"fobnail-api/#admintoken_provision","title":"/admin/token_provision","text":"<p>PO certificate chain is transferred as an ordered array of raw DER certificates, starting with the certificate directly after the root certificate (the Fobnail Token already knows the root).</p> <pre><code>{\n    // Array of certificates in DER format (major 4)\n    \"certs\": [\n        // CA immediately under root (major 2)\n        [ 0x30, 0x82, 0x03, 0x8b, ... ],\n        // Intermediate CAs, if any\n        ...\n        // PO certificate for certificate signing (major 2)\n        [ 0x30, 0x82, 0x04, 0x8f, ... ]\n    ],\n}\n</code></pre> <p>Fobnail Token verifies certificate the chain against the trust anchor embedded into its firmware. If verification fails, 4.03 is returned.</p> <p>On success, Fobnail generates an Identity/Encryption key, prepares a Certificate Signing Request, and responds with a 2.01 status code, response must contain CSR as a payload. CSR is sent in DER format and <code>Content-Format</code> must be set to <code>application/octet-stream</code>.</p>"},{"location":"fobnail-api/#adminprovision_complete","title":"/admin/provision_complete","text":"<p>The client sends a certificate generated from CSR previously provided by <code>/admin/token_provision</code>. Fobnail Token verifies the provided certificat correctness, such as whether it is properly signed, has correct extensions defined, etc. On error 4.03 is returned.</p> <p>On success, 2.01 is returned, and provisioning is complete.</p> <p>The certificate is sent as a raw DER, and <code>Content-Format</code> must be set to <code>application/octet-stream</code>, or the request will be rejected. Future API versions may accept <code>application/cbor</code>.</p>"},{"location":"fobnail-api/#platform-provisioning","title":"Platform provisioning","text":"Endpoint Name Method Arguments /admin/provision/ek POST EK certificate chain /admin/provision/aik POST AIK public part /admin/provision POST Credential Activation result /admin/provision/{id}/meta POST Platform metadata /admin/provision/{id}/rim POST Reference Integrity Measurements /admin/provision/{id} POST None"},{"location":"fobnail-api/#adminprovisionek","title":"/admin/provision/ek","text":"<p>EK certificate chain is transferred in the same format as PO certificate chain described above. The certificate directly after the root certificate is the first certificate in the array, while the EK certificate is the last.</p> <p>Client issues POST request with <code>Content-Format</code> set to <code>application/cbor</code> and payload containing CBOR-encoded certificate array as described above. Fobnail Token verifies the provided certificate chain against one of the roots embedded into its firmware. On success 2.01 response is returned, <code>Location-Path</code> contains EK object ID. If EK certificate chain verification fails, 4.03 is returned.</p>"},{"location":"fobnail-api/#adminprovisionaik","title":"/admin/provision/aik","text":"<p>AIK is transferred in TPM format (TPM2B_PUBLIC structure). Re-encoding this into CBOR would strip essential data. Fobnail needs unmodified TPM2B_PUBLIC to successfully perform the \"make credential\" operation which is needed for credential activation. Unmodified AIK and EK object ID are wrapped into CBOR:</p> <pre><code>{\n    // AIK (TPM2B_PUBLIC, major 2)\n    \"aik\": [0x20, 0x01, 0x00, ...],\n    // EK object ID (major 0 - unsigned integer)\n    \"ek\": 1\n}\n</code></pre> <p>Fobnail Token verifies whether AIK is a valid TPM2B_PUBLIC and whether the key's algorithm is supported. On success, 2.01 response is returned, and <code>Location-Path</code> contains AIK object ID. Response payload contains a challenge (Make Credential) prepared using the provided AIK and EK.</p> <pre><code>{\n    \"idObject\": [0x20, 0x02, 0x10, ...],\n    \"encSecret\": [0x20, 0x02, 0x10, ...],\n}\n</code></pre> <p>If AIK verification fails, 4.03 is returned, and the payload may contain additional context. If provided EK object ID is invalid, 4.04 is returned.</p>"},{"location":"fobnail-api/#adminprovision","title":"/admin/provision","text":"<p>This endpoint is used to create a Provisioning Context. The client provides the result of Credential Activation as a payload:</p> <pre><code>{\n    // EK object ID of the EK used to make the challenge (major 0)\n    \"ek\": 1,\n    // AIK object ID of the AIK used to make the challenge (major 0)\n    \"aik\": 2,\n    // Decrypted secret - output of TPM Credential Activation (major 2)\n    \"secret\": [0x00, 0x01, 0x02, 0x03, ...]\n}\n</code></pre> <p>Fobnail Token verifies whether the decrypted secret matches the secret kept in Fobnail Token's memory. If verification is successful, Fobnail Token creates a Provisioning Context and responds with a 2.01 response (<code>Location-Path</code> contains Provisioning Context ID).</p> <p>If the secret does not match, 4.03 is returned. If either EK object ID or AIK object ID is invalid, 4.04 is returned.</p>"},{"location":"fobnail-api/#adminprovisionidmeta","title":"/admin/provision/{id}/meta","text":"<p>This method is used to upload platform metadata. After upload, the platform metadata is bound to the provisioning context specified by <code>{id}</code>.</p> <p>Metadata is sent in CBOR-encoded format (also described here in more detail). Example metadata looks like this</p> <pre><code>{\n    // metadata version, used to detect backward-incompatible changes\n    // (major 0, unsigned integer)\n    \"version\": 1,\n    // device manufacturer extracted from SMBIOS tables (major 3, UTF-8 string)\n    \"manufacturer\": \"Gigabyte\",\n    // device model extracted from SMBIOS tables (major 3, UTF-8 string)\n    \"model\": \"Gigabyte A520 AORUS ELITE\",\n    // MAC address of primary network card (major 2, byte string)\n    \"mac\": [0xea, 0x96, 0x91, 0x87, 0x26, 0x8d],\n    // device serial number extracted from SMBIOS tables (major 3, UTF-8 string)\n    \"sn\": \"S21N559B431\",\n}\n</code></pre> <p>Client must sign metadata with AIK (see the Data signing section above).</p> <p>Fobnail Token verifies the provided metadata against AIK bound to the Provisioning Context. If signature verification fails, 4.03 is returned. If the metadata format is invalid, 4.00 is returned. On success, either 2.01 or 2.04 are returned. On the first successful call, 2.01 is returned (<code>Location-Path</code> must not be present), and on subsequent calls, 2.04 is returned to signify that metadata has been replaced.</p>"},{"location":"fobnail-api/#adminprovisionidrim","title":"/admin/provision/{id}/rim","text":"<p>RIM holds PCR registers (from TPM) which are used for attestation. It doesn't contain information about the Attester since these are part of the metadata. RIM may contain multiple PCR banks (depending on the hash algorithm: SHA-1, SHA-256, others). Each PCR bank contains a bitmap of present PCRs (<code>pcrs</code> field) and an array of PCR itself. The LSB of bitmap corresponds to PCR0. RIMs are sent in CBOR:</p> <pre><code>{\n    // PCR update counter, incremented every time when some PCR gets updated.\n    \"update_ctr\": 0,\n    // Array of PCR banks (major 4)\n    \"banks\": [\n        // First PCR bank\n        {\n            // Algorithm ID as used by TPMs (TPM2_ALG_* constants from libtss)\n            // (major 0, unsigned integer)\n            \"algo_id\": 0xb,\n            // Bitmap of present PCRs (major 0, unsigned integer)\n            \"pcrs\": 0xffffffff,\n            // Array of PCR registers, each register holds hash corresponding to the\n            // type of bank.\n            // There must be as many hashes as set bits in \"pcrs\" field. If\n            // these don't match then RIM is considered invalid.\n            \"pcr\": [\n                // Size of hash is verified, whether all hashes in a bank have\n                // the same size, if these don't match then entire RIM is\n                // considered invalid\n                [ 0x00, 0x00, 0x00, 0x00, ... ],\n                ...\n            ]\n        },\n        // Another PCR bank (major 5, map)\n        {\n            \"algo_id\": 0xb,\n            \"pcrs\": 0x000000ff,\n            // major 4 (array)\n            \"pcr\": [\n                // major 2 (byte string)\n                [ 0x00, 0x00, 0x00, 0x00, ... ],\n                ...\n            ]\n        }\n    ],\n}\n</code></pre> <p>Client must sign RIM with AIK (see the Data signing section above).</p> <p>Fobnail Token verifies RIM signature and format. If signature verification fails, 4.03 is returned. If RIM has an invalid format, 4.00 is returned. On success 2.01 or 2.04 is returned. On the first successful call, 2.01 is returned (<code>Location-Path</code> must not be present); on subsequent calls, 2.04 is returned to signify that the previous RIM has been replaced with the new RIM.</p>"},{"location":"fobnail-api/#adminprovisionid","title":"/admin/provision/{id}","text":"<p>POST request to this endpoint results in writing data attached to the Provisioning Context into persistent storage. Currently, this request does not contain any data, and payload must be empty or 4.00 response will be returned.</p> <p>Fobnail Token verifies whether all required data has been provided (metadata and RIM is mandatory). On error, 4.03 response is returned. If verification is successful, Fobnail Token writes all required data into persistent storage, completing the provisioning process. If an error occurs while writing into persistent storage, 5.00 is returned (the payload may contain additional context). On success, 2.04 response is returned to signify provisioning is complete. At this point, the Provisioning Context becomes invalid, and all subsequent requests to the Provisioning Context will return 4.04.</p>"},{"location":"fobnail-api/#attestation","title":"Attestation","text":"Endpoint Name Method Arguments /attest POST Platform metadata /attest/{id} POST Output of TPM quote"},{"location":"fobnail-api/#attest","title":"/attest","text":"<p>The client sends platform metadata in the same format as when calling <code>/admin/provision/{id}/meta</code>. Metadata must be signed by the same AIK that was used during platform provisioning. If verification is successful 2.01 is returned (otherwise 4.04) and <code>Location-Path</code> contains Attestation Context ID. The response's payload contains PCR selection and nonce:</p> <pre><code>{\n    // Array of PCR banks (major 4)\n    \"banks\": [\n        // First PCR bank\n        {\n            // ID of algorithm used by PCRs (major 0)\n            \"algo_id\": 0x0004,\n            // Bitmap of present PCRs (major 0, unsigned integer)\n            \"pcrs\": 0xffffffff,\n        },\n        // Another PCR bank (major 5, map)\n        {\n            \"algo_id\": 0x000b,\n            \"pcrs\": 0x000000ff,\n        }\n    ],\n    // Nonce to be passed to TPM_Quote() (major 2)\n    \"nonce\": [0x00, 0x01, 0x02, 0x03, ...]\n}\n</code></pre> <p>The PCR selection format is similar to that of RIM but stripped of unnecessary fields. Due to the nature of PCR selection parsing done by <code>TPM2_Quote()</code>, order of PCR banks matters.</p>"},{"location":"fobnail-api/#attestid","title":"/attest/{id}","text":"<p>The client sends the evidence to this endpoint (the result of TPM Quote). Based on the evidence, Fobnail Token decides whether the platform is trustworthy or not. If Fobnail Token decides that the platform is trustworthy, 2.04 response is returned, 4.03 otherwise.</p> <p>If attestation is successful, Fobnail Token unlocks access to the Fobnail Token Services.</p>"},{"location":"fobnail-api/#fobnail-token-services","title":"Fobnail Token Services","text":"<p>Fobnail Token Services are available after successful platform attestation. Fobnail Token can store cryptographic keys (or other data) in its internal flash. Depending on the key's type (symmetric or asymmetric) and usage permissions, various operations are available. For symmetric keys, it is encryption and decryption. For asymmetric keys, it is signing, decryption, KDF, and public key read (the client extracts the public key and does encryption on its own).</p> <p>Key, once created, may not be read (except for the public key). Fobnail Token performs cryptographic operations on behalf of the client, which may be slow. If this behavior is undesired, Secure Storage may be used instead to store the key as a file inside Fobnail Token.</p> Endpoint Name Method Arguments /crypto POST Key name, type, etc. /crypto/{id}/type GET None /crypto/{id}/encrypt POST Data to encrypt /crypto/{id}/decrypt POST Data to decrypt /crypto/{id}/sign PUT Data to sign /crypto/{id}/pub GET None /storage/fs/{name} GET File name /storage/fs/{name} PUT File name and file contents /storage/fs/{name} DELETE File name <p>If the platform has not been attested (or failed attestation), these APIs will return a 4.04 error. If attestation is successful, Fobnail Token checks whether a specified key exists and whether the platform has access to that key. If the key or file does not exist or there is no access 4.04 error is returned.</p> <p>Note: currently, crypto API is not fully defined. Future versions of this document will address this problem.</p>"},{"location":"fobnail-api/#get-storagefsname","title":"GET /storage/fs/{name}","text":"<p>The client sends a request to this endpoint to read a file. The file path is encoded as part of the URI. If the file exists (and if it's accessible), 2.05 response is sent with the file contents as the payload. <code>Max-Age</code> option must be set to 0 to prevent caching. ETag option must not be present in the response, and if present in the request, it must be ignored.</p> <p>The GET method always returns the full contents of the file. Further versions of this document may define API using the FETCH method from RFC8132.</p> <p>Fobnail Token attempts to open the requested file and returns 2.05 response with file contents. 4.04 is returned if the file does not exist or there is no access.</p>"},{"location":"fobnail-api/#put-storagefsname","title":"PUT /storage/fs/{name}","text":"<p>This endpoint is used to write file contents. Fobnail Token attempts to write the specified file (URI) with the provided payload. If successful, Fobnail Token returns either 2.01 (when the file has been created) or 2.04 (when the file has been updated). Request may fail in the following situations:</p> <ul> <li>If the name contains invalid characters (name may not contain NULLs and slash,   '.' and '..' names are banned), 4.03 error is returned.</li> <li>If the platform is not allowed to create a file, 4.03 error is returned.</li> <li>If writing the file failed for any reason - 5.00 error (payload may   contain additional context).</li> </ul>"},{"location":"fobnail-api/#delete-storagefsname","title":"DELETE /storage/fs/{name}","text":"<p>This endpoint is used to delete a file. The file name is provided in URI, and the payload should be empty. On success, or if the file didn't exist before 2.02 is returned. On error, such as when the file does exist, but there is no permission to remove it, 4.03 is returned.</p>"},{"location":"fobnail-sdk/","title":"Fobnail SDK","text":"<p>Fobnail SDK is a Docker container image that contains all the tools required to build Fobnail Token firmware, flash it to nRF52840 dongle and debug it.</p> <p>Full repository can be found here, but to use it you can just simply download script <code>run-fobnail-sdk.sh</code> and save it to a directory in your <code>PATH</code> environment variable:</p> <pre><code>sudo wget -O /usr/local/bin/run-fobnail-sdk.sh \\\n  https://raw.githubusercontent.com/fobnail/fobnail-sdk/main/run-fobnail-sdk.sh\nsudo chmod +x /usr/local/bin/run-fobnail-sdk.sh\n</code></pre> <p>For proper operation, you need to have Docker installed and properly configured.</p> <p>First execution of this script downloads Docker container image, which can be both time- and bandwidth-consuming. Running this script without any additional parameters will open interactive shell.</p>"},{"location":"fobnail_token/","title":"Resources","text":"<ul> <li>nRF52840 dongle schematics</li> <li>nRF52840 development kit schematics</li> <li>nRF52840 dongle user guide</li> <li>nRF52840 development kit user guide</li> </ul>"},{"location":"implementing-eth-over-usb/","title":"Implementing Ethernet-over-USB","text":"<p>This document describes various stuff regarding implementation of Ethernet-over-USB. Before commencing implementation we have conducted research (see eth-over-usb-research.md) for more information. To sum up, that's what we have decided:</p> <ul> <li>we run on bare-metal using <code>nrf-hal</code></li> <li>we use EEM protocol for Ethernet emulation and <code>smoltcp</code> as TCP/IP stack</li> </ul>"},{"location":"implementing-eth-over-usb/#used-crates","title":"Used crates","text":"<p>We are using following crates</p> <ul> <li> <p><code>nrf-hal</code> - provides things related directly to nRF52840 hardware, like   register definitions, interrupt handling support, for some peripherals   provides higher-level API (Timers, GPIO, ...)</p> </li> <li> <p><code>nrf-usb</code> - provides implementation of <code>UsbBus</code> trait (from <code>usb-device</code>   crate)</p> </li> <li> <p><code>usb-device</code> - high level USB driver, on top of this we are building EMM   driver</p> </li> </ul>"},{"location":"implementing-eth-over-usb/#encountered-problems","title":"Encountered problems","text":"<p>During implementation of EEM driver we have encountered following problems</p> <ul> <li> <p><code>nrf-usb</code> does not provide interrupt support, we have worked around this   problem by continuously polling USB, for testing purposes it is good enough   but ideally we should use interrupt-driven model.</p> </li> <li> <p><code>nrf-usb</code> underpowers DMA - during DMA transfers CPU busy-waits in a loop   till transfer is complete   (see here)</p> </li> <li> <p><code>usb-device</code> API limitation - we cannot read single packet into two   non-contiguous memory regions, because of that we cannot use ring buffer, as a   temporary workaround we implemented a simple linear buffer where data is   appended to the tail, removing data from the front requires moving of large   amounts of memory which is very suboptimal. The same problem affects writes.</p> </li> <li> <p>smoltcp callback accepts a pointer to a continuous buffer, so we can't use   ring buffer anyway</p> </li> <li> <p>seems like <code>nrf-hal</code> provides no high level API for setting periodic timers   with automatic counter reset (does the hardware support it?), counter must be   manually reset on each interrupt handler invocation, or interrupt will keep   firing instantly one after another.</p> </li> <li> <p>integration of smoltcp may be quite hard to do efficiently - smoltcp uses   producer consumer model, when reading data from Ethernet smoltcp calls   <code>consume()</code> method providing a callback that is called when next Ethernet   frame is ready, so we have to efficiently transfer Ethernet frame from USB   thread to smoltcp thread, we want to avoid copying memory around as much as   possible.</p> </li> <li> <p>USB driver tends to hang if attempting to write packets into full buffer. When   we send USB packets to the host we call <code>usb_device::EndpointIn::write</code> method   which transfers packet to USBD internal memory, packet is actually sent when   host polls the endpoint. If USBD memory is full   <code>usb_device::EndpointIn::write</code> returns <code>WouldBlock</code> error. Now calling   <code>write()</code> a few times more causes the driver to deadlock forever (TX only, RX   still works). To workaround this we must track state TX buffer ourselves: when   we get <code>WouldBlock</code> we freeze any further transfers until USBD signals us that   previous packet was sent.</p> </li> <li> <p>Device is enumerated as a full-speed device instead of high-speed, because of   that we cannot use max packet size larger than 64 bytes.</p> </li> </ul>"},{"location":"implementing-eth-over-usb/#status-of-current-implementation","title":"Status of current implementation","text":"<p>We have a working implementation with an echo service exposed over UDP port <code>9400</code>. Fobnail has IP address <code>169.254.0.1/16</code>. Host must have a manually assigned IP address as there is no DHCP. EEM implementation has few limitations which aren't a big problem for a PoC, but should eventually be solved.</p> <ul> <li>EEM driver cannot handle EEM packets exceeding internal buffer size (driver   will panic).</li> <li>EEM driver will panic when encounters an invalid EEM packet.</li> <li>because of problems described above we have to use a linear FIFO (instead of   ring), maybe we could somehow optimize it?</li> <li>driver needs more testing.</li> <li>Linux's NetworkManager tries to configure EEM network interface over DHCP   which fails. Then tries doing it again, showing every time an error message   and breaking internet connection (about every half minute). This is a Network   Managers's bug, but it affects Fobnail users. You can workaround this by   appending following lines to <code>/etc/NetworkManager/NetworkManager.conf</code> <pre><code>[keyfile]\nunmanaged-devices=interface-name:usb0\n</code></pre></li> </ul>"},{"location":"implementing-eth-over-usb/#testing","title":"Testing","text":"<p>If your environment is properly set up, app can be flashed by simply running</p> <pre><code>$ cargo embed\n</code></pre> <p><code>cargo embed</code> spawns RTT console used for debugging. On host you should see new network interface.</p> <pre><code>$ ifconfig -a usb0\nusb0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1500\n        ether 86:7e:55:2c:a7:b5  txqueuelen 1000  (Ethernet)\n        RX packets 0  bytes 0 (0.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 0  bytes 0 (0.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> <p>Assign IP address to <code>usb0</code>, Fobnail token is at <code>169.254.0.1</code></p> <pre><code>$ ifconfig usb0 169.254.0.2\n</code></pre> <p>Fobnail should start to print debug information on RTT console. Note that these errors are caused by host sending IPv6 packets. IPv6 support is disabled in <code>smoltcp</code>.</p> <pre><code>16:51:15.107 TRACE smoltcp::iface::neighbor &gt; filled 169.254.0.8 =&gt; ae-89-60-61-ca-4f (was empty)\n16:51:15.133 DEBUG smoltcp::iface::ethernet &gt; cannot process ingress packet: unrecognized packet\n16:51:15.133 DEBUG smoltcp::iface::ethernet &gt; packet dump follows:\n16:51:15.133 EthernetII src=ae-89-60-61-ca-4f dst=33-33-00-00-00-16 type=IPv6\n16:51:15.133 ERROR fobnail_poc &gt; smoltcp error: unrecognized packet\n16:51:15.224 DEBUG smoltcp::iface::ethernet &gt; cannot process ingress packet: unrecognized packet\n16:51:15.224 DEBUG smoltcp::iface::ethernet &gt; packet dump follows:\n16:51:15.224 EthernetII src=ae-89-60-61-ca-4f dst=33-33-00-00-00-16 type=IPv6\n16:51:15.224 ERROR fobnail_poc &gt; smoltcp error: unrecognized packet\n16:51:15.691 DEBUG smoltcp::iface::ethernet &gt; cannot process ingress packet: unrecognized packet\n16:51:15.691 DEBUG smoltcp::iface::ethernet &gt; packet dump follows:\n16:51:15.691 EthernetII src=ae-89-60-61-ca-4f dst=33-33-ff-61-ca-4f type=IPv6\n16:51:15.691 ERROR fobnail_poc &gt; smoltcp error: unrecognized packet\n16:51:16.669 DEBUG smoltcp::iface::ethernet &gt; cannot process ingress packet: unrecognized packet\n16:51:16.669 DEBUG smoltcp::iface::ethernet &gt; packet dump follows:\n16:51:16.669 EthernetII src=ae-89-60-61-ca-4f dst=33-33-00-00-00-16 type=IPv6\n16:51:16.669 ERROR fobnail_poc &gt; smoltcp error: unrecognized packet\n16:51:16.697 DEBUG smoltcp::iface::ethernet &gt; cannot process ingress packet: unrecognized packet\n16:51:16.697 DEBUG smoltcp::iface::ethernet &gt; packet dump follows:\n16:51:16.697 EthernetII src=ae-89-60-61-ca-4f dst=33-33-00-00-00-02 type=IPv6\n16:51:16.697 ERROR fobnail_poc &gt; smoltcp error: unrecognized packet\n</code></pre> <p>Fobnail responds to ICMP echo requests:</p> <pre><code>$ ping 169.254.0.1\nPING 169.254.0.1 (169.254.0.1) 56(84) bytes of data.\n64 bytes from 169.254.0.1: icmp_seq=1 ttl=64 time=24.7 ms\n64 bytes from 169.254.0.1: icmp_seq=2 ttl=64 time=23.1 ms\n64 bytes from 169.254.0.1: icmp_seq=3 ttl=64 time=22.2 ms\n64 bytes from 169.254.0.1: icmp_seq=4 ttl=64 time=21.4 ms\n64 bytes from 169.254.0.1: icmp_seq=5 ttl=64 time=30.3 ms\n64 bytes from 169.254.0.1: icmp_seq=6 ttl=64 time=29.4 ms\n64 bytes from 169.254.0.1: icmp_seq=7 ttl=64 time=28.2 ms\n</code></pre> <p>Fobnail has an echo service exposed on UDP port <code>9400</code>, when you line of text it will be echoed back.</p> <pre><code>$ nc -u 169.254.0.1 9400\ntest\ntest\n1234567890\n1234567890\n</code></pre>"},{"location":"keys_and_certificates/","title":"Keys and certificates","text":"<p>Many different keys and certificates are used by all of Fobnail's components. Most of them are automatically generated, but some must be provided by user.</p>"},{"location":"keys_and_certificates/#list-of-keys-and-certificates-used","title":"List of keys and certificates used","text":"<p>Refer to architecture doc for description of actors and phases listed below. List items have the following format:</p> <ul> <li>Name of key or certificate<ul> <li>Phase during which it is obtained, received or used</li> <li>Other details, if any</li> </ul> </li> </ul> <p>Note that this list includes possible usages that may not be implemented yet.</p>"},{"location":"keys_and_certificates/#platform-owner","title":"Platform Owner","text":""},{"location":"keys_and_certificates/#knows-in-advance","title":"Knows in advance","text":"<ul> <li>Platform Owner key (signing and encryption)<ul> <li>Fobnail and remote platform provisioning</li> <li>used for TLS and for signing certificates</li> </ul> </li> <li>Platform Owner certificate<ul> <li>Fobnail and remote platform provisioning</li> <li>has to be able to provide whole CA chain</li> <li>both Fobnail Token and Platform must trust root CA in this chain</li> </ul> </li> <li>root CA certificate for EK certificate chain<ul> <li>remote platform provisioning</li> </ul> </li> </ul>"},{"location":"keys_and_certificates/#receives","title":"Receives","text":"<ul> <li>Fobnail Identity key<ul> <li>Fobnail provisioning</li> </ul> </li> <li>Fobnail Encryption key<ul> <li>Fobnail provisioning</li> </ul> </li> <li>EK certificate<ul> <li>remote platform provisioning</li> </ul> </li> <li>AIK<ul> <li>remote platform provisioning</li> </ul> </li> </ul>"},{"location":"keys_and_certificates/#produces","title":"Produces","text":"<ul> <li>Fobnail Identity certificate<ul> <li>Fobnail provisioning</li> </ul> </li> <li>Fobnail Encryption certificate<ul> <li>Fobnail provisioning</li> </ul> </li> <li>AIK certificate<ul> <li>remote platform provisioning</li> <li>simple signature instead of certificate may be sufficient</li> </ul> </li> </ul>"},{"location":"keys_and_certificates/#fobnail-token","title":"Fobnail Token","text":""},{"location":"keys_and_certificates/#knows-in-advance_1","title":"Knows in advance","text":"<ul> <li>root CA certificate for EK certificate chain<ul> <li>local platform provisioning</li> </ul> </li> <li>root CA for Platform Owner certificate chain<ul> <li>Fobnail provisioning</li> </ul> </li> </ul>"},{"location":"keys_and_certificates/#receives_1","title":"Receives","text":"<ul> <li>Platform Owner certificate chain<ul> <li>Fobnail provisioning</li> <li>saved in flash, used in local platform provisioning and attestation</li> </ul> </li> <li>Fobnail Identity certificate<ul> <li>Fobnail provisioning</li> <li>signed by Platform Owner</li> </ul> </li> <li>Fobnail Encryption certificate<ul> <li>Fobnail provisioning</li> <li>signed by Platform Owner</li> </ul> </li> <li>EK certificate<ul> <li>local platform provisioning</li> </ul> </li> <li>AIK<ul> <li>local platform provisioning</li> <li>remote platform provisioning - signed by Platform Owner</li> <li>stored in flash and used during attestation</li> </ul> </li> </ul>"},{"location":"keys_and_certificates/#produces_1","title":"Produces","text":"<ul> <li>Fobnail Identity key (signing and encryption)<ul> <li>Fobnail provisioning</li> <li>key and certificate signed by Platform Owner is stored for later use</li> </ul> </li> <li>Fobnail Encryption key (encryption)<ul> <li>Fobnail provisioning</li> </ul> </li> </ul>"},{"location":"keys_and_certificates/#platform","title":"Platform","text":""},{"location":"keys_and_certificates/#knows-in-advance_2","title":"Knows in advance","text":"<ul> <li>root CA for Platform Owner certificate chain<ul> <li>remote platform provisioning</li> <li>local platform provisioning and attestation - Fobnail Identity key is signed by Platform Owner, so Platform needs a way of verifying trust chain</li> </ul> </li> <li>Endorsement Key (encryption)<ul> <li>remote and local platform provisioning</li> <li>for this project may be considered immutable persistent key unique to TPM</li> </ul> </li> <li>EK certificate<ul> <li>EK is unique so is its certificate</li> <li>usually saved in TPM NVRAM</li> <li>signed by TPM manufacturer CA</li> </ul> </li> </ul>"},{"location":"keys_and_certificates/#receives_2","title":"Receives","text":"<ul> <li>Platform Owner certificate chain<ul> <li>remote platform provisioning - directly from Platform Owner</li> <li>local platform provisioning and attestation - from Fobnail Token</li> <li>used for identification, TLS and verifying Fobnail Identity certificate</li> </ul> </li> <li>Fobnail Identity certificate<ul> <li>local platform provisioning and attestation</li> <li>used for identification and TLS</li> </ul> </li> </ul>"},{"location":"keys_and_certificates/#produces_2","title":"Produces","text":"<ul> <li>Attester Identity Key (signing)<ul> <li>local and remote platform provisioning</li> <li>created by TPM</li> <li>trusted based on Make/ActivateCredential and pairing with EK instead of certificate</li> </ul> </li> </ul>"},{"location":"keys_and_certificates/#platform-owner-certificate-chain","title":"Platform Owner certificate chain","text":"<p>Platform Owner trust chain uses X.509 certificates, usually in PEM format. It aims to be compatible with standard Public Key Infrastructure, as described in RFCs 5280 or 3647, among others. At least basic understanding of PKI is strongly suggested, but if you just want to quickly test Fobnail, you may just do steps in TL;DR section.</p> <p>Platform Owner certificate is used during Fobnail provisioning. Its root CA certificate must be preinstalled on Fobnail Token. Due to limited hardware capabilities of Fobnail Token, following restrictions apply.</p>"},{"location":"keys_and_certificates/#validity-checks","title":"Validity checks","text":""},{"location":"keys_and_certificates/#informational-checks","title":"Informational checks","text":"<ul> <li> <p>Maximum certificate chain length</p> <p>Maximal supported certificate chain consists of 3 CA certificates: root CA (flashed to Fobnail's memory), intermediate CA and final CA that is used to issue certificates for keys generated by Fobnail. Intermediate CA is optional, root and issuing CA aren't. During Fobnail provisioning, Platform Owner generates one additional certificate for Token, but this final certificate doesn't allow for use as a CA.</p> <p>This limit comes from hardware limitations (in terms of available memory) aggravated by chosen library (Trussed) and its limitations.</p> </li> <li> <p>File format</p> <p>Certificates are concatenated to a single PEM file. Order of concatenation matters, certificates must be written starting with root CA certificate and moving through intermediate towards leaf certificate. All of them must be present, despite the fact that root CA is already known by Fobnail.</p> </li> <li> <p>Certificate extensions</p> <p>Trust chain will be traversed based on <code>X509v3 Authority Key Identifier</code> extension which is compared against <code>X509v3 Subject Key Identifier</code>, so both of them must be included in every certificate (former should be skipped for root CA). <code>X509v3 Basic Constraints</code> is required for CA certificates. <code>X509v3 Key Usage</code> must specify that all certificates in Platform Owner chain are able to sign certificates.</p> </li> </ul>"},{"location":"keys_and_certificates/#temporal-checks","title":"Temporal checks","text":"<ul> <li>Validity period</li> </ul> <p>Reference Fobnail Token (nRF52840 dongle) has no timekeeping capabilities. Because of that, validity period cannot be tested without adding another party that Fobnail Token trusts, or by using another dongle for Fobnail Token.</p> <ul> <li>Certificate revocation</li> </ul> <p>Fobnail Token doesn't have trusted network connection, so it can't access recent (i.e. one that happened after last firmware update) certificate revocation list at run time. Revocations can only be applied during flashing/update, which should be done by Platform Owner. During that process, attempt to use revoked certificates should result in failed provisioning.</p>"},{"location":"keys_and_certificates/#creating-platform-owner-certificate-chain-with-openssl","title":"Creating Platform Owner certificate chain with OpenSSL","text":"<p>This section describes how to create a certificate chain that conforms to restrictions mentioned earlier. This is just a minimal example showing all required configuration options and commands used in the process, fields listed here may be extended or modified, but should not be removed. Normally CAs do much more than what is presented here, some guidelines can be found in RFC 3647.</p> <p>Note that root CA doesn't have to be under Platform Owner's control, but it must issue a certificate that is (either directly or through intermediate issuer). In such cases the issuer may use other form of certificate request or additional mechanisms of proving the identity of the requester than those used by OpenSSL.</p>"},{"location":"keys_and_certificates/#root-ca","title":"Root CA","text":"<p>Root CA certificate is self-signed. This means that signed public and signing private keys belong to the same pair, and no exchange of data between separate entities happens. <code>-x509</code> parameter tells that this is the case and a self-signed certificate is to be made, instead of CSR (Certificate Signing Request).</p> <ul> <li> <p>First create configuration file <code>root_ca.cfg</code>, for example:</p> <pre><code>[ req ]\ndistinguished_name     = req_distinguished_name\nprompt                 = no\nx509_extensions        = v3_ext\n\n[ req_distinguished_name ]\nC                      = PL\nO                      = Fobnail\nST                     = State\nCN                     = Platform Owner root CA certificate\n\n[v3_ext]\nbasicConstraints       = critical, CA:TRUE, pathlen:3\nkeyUsage               = critical, keyCertSign, cRLSign\nsubjectKeyIdentifier   = hash\nauthorityKeyIdentifier = keyid:always\n</code></pre> <p>Feel free to adjust configuration to your needs.</p> </li> <li> <p>Run command:</p> <pre><code>openssl req -newkey rsa:2048 -nodes -keyout root_ca_priv.pem -x509 -days 365 \\\n-out root.crt -config root_ca.cfg\n</code></pre> <ul> <li><code>root_ca_priv.pem</code> - newly created private root CA key. Keep it safe.</li> <li><code>root.crt</code> - root CA certificate. This will be hardcoded and marked as   trusted by Fobnail Token.</li> </ul> </li> </ul>"},{"location":"keys_and_certificates/#intermediatepo-issuing-ca","title":"Intermediate/PO issuing CA","text":"<p>Note: \"PO issuing CA\" in this part of the document should be understood as the CA that issues certificate requested by Fobnail Token. In general, each certificate has its own issuer. If that meaning of the word is required, \"higher-level CA\", \"intermediate CA\" or \"root CA\" is used.</p> <p>These certificates aren't self-signed. Creation of such certificates consists of two steps: first one is generating a CSR (Certificate Signing Request) and is done by key creator, second one is creating the certificate itself - this is done by the parent CA. This separation is done to keep private keys secret at all times.</p> <p>Steps for both intermediate and issuing CA certificates are mostly the same, the main difference is that CSR for intermediate is sent to root CA, and PO issuing CA's CSR is sent to intermediate CA. This chain can be longer in general, but Fobnail limits maximum length, as mentioned above. Intermediate CA is optional, PO issuing CA certificate can be signed by root CA directly.</p> <p>Before issuing a certificate, issuer must check if subject is authorized to ask for it. It can't just blindly provide a new certificate to anyone that asks for it, because by creating a signed certificate CA tells others that it trusts its subject. Trust decision can be based on fields of CSR, challenge password, secure and non-public way of conveying CSR to issuer, or other means. Sometimes the decision is made by another entity called Registration Authority (RA) on behalf of CA.</p> <p>In this case because subject of each signed certificate is itself a CA and can create certificates for other entities. Certificate revocation for Fobnail can't be done by means other than firmware updates, so issuing a certificate to untrustworthy subject impacts not only the security of devices provisioned by issuer, but also every device with the same root CA.</p>"},{"location":"keys_and_certificates/#generating-intermediate-ca-key-and-csr","title":"Generating intermediate CA key and CSR","text":"<p>This is similar to creating root CA with two small but important differences:</p> <ul> <li><code>-x509</code> flag is not used in the command line</li> <li><code>x509_extensions</code> are not present (those are added by the issuer)</li> </ul> <p>Command executed by intermediate CA:</p> <pre><code>openssl req -newkey rsa:2048 -nodes -keyout intermediate_priv_key.pem\n-out intermediate.csr -config intermediate.cfg\n</code></pre> <ul> <li><code>intermediate_priv_key.pem</code> (out) - newly created private intermediate CA key.   Keep it safe.</li> <li><code>intermediate.csr</code> (out) - intermediate CA certificate signing request. This   file is signed with private intermediate CA key by above command and must be   passed to root CA.</li> <li><code>intermediate.cfg</code> (in) - configuration file, e.g.:</li> </ul> <pre><code>[ req ]\ndistinguished_name     = req_distinguished_name\nprompt                 = no\n\n[ req_distinguished_name ]\nC                      = PL\nO                      = Fobnail\nST                     = State\nCN                     = Intermediate CA certificate\n</code></pre>"},{"location":"keys_and_certificates/#generating-intermediate-ca-certificate","title":"Generating intermediate CA certificate","text":"<p><code>openssl ca</code> can also be used for this purpose, but <code>openssl x509</code> is easier to use for single chain. On the other hand, <code>openssl ca</code> better suits the needs of CA after configuration and may do more checks in semi-automatic process than <code>openssl x509</code>.</p> <p>Command executed by root CA:</p> <pre><code>openssl x509 -req -in intermediate.csr -CA root.crt -CAkey root_ca_priv.pem \\\n    -CAcreateserial -days 365 -extfile intermediate.ext -out intermediate.crt\n</code></pre> <ul> <li><code>intermediate.csr</code> (in) - sent by intermediate CA.</li> <li><code>root.crt</code> and <code>root_ca_priv.pem</code> (in) - those were created by root CA   earlier.</li> <li><code>intermediate.crt</code> (out) - intermediate CA certificate signed with root CA key   <code>root_ca_priv.pem</code>.</li> <li><code>intermediate.ext</code> (in) - file describing certificate extensions, e.g.:</li> </ul> <pre><code>basicConstraints       = critical, CA:TRUE, pathlen:2\nkeyUsage               = critical, keyCertSign, cRLSign\nsubjectKeyIdentifier   = hash\nauthorityKeyIdentifier = keyid:always\n</code></pre>"},{"location":"keys_and_certificates/#generating-po-issuer-ca-key-and-csr","title":"Generating PO issuer CA key and CSR","text":"<p>Command executed by PO issuer CA:</p> <pre><code>openssl req -newkey rsa:2048 -nodes -keyout root_ca_priv.pem -out issuer.csr \\\n-config issuer.cfg\n</code></pre> <ul> <li><code>root_ca_priv.pem</code> (out) - newly created private PO issuing CA key. Keep it   safe.</li> <li><code>issuer.csr</code> (out) - PO issuing CA certificate signing request. This file is   signed with private PO issuing CA key by above command and must be passed to   intermediate CA.</li> <li><code>issuer.cfg</code> (in) - configuration file, e.g.:</li> </ul> <pre><code>[ req ]\ndistinguished_name     = req_distinguished_name\nprompt                 = no\n\n[ req_distinguished_name ]\nC                      = PL\nO                      = Fobnail\nST                     = State\nCN                     = Platform Owner issuer CA certificate\n</code></pre>"},{"location":"keys_and_certificates/#generating-po-issuer-ca-certificate","title":"Generating PO issuer CA certificate","text":"<p>Command executed by intermediate CA:</p> <pre><code>openssl x509 -req -in issuer.csr -CA $AUTHORITY_CERT -CAkey $AUTHORITY_PRIV \\\n        -CAcreateserial -days 365 -extfile $SUBJECT_EXT -out $SUBJECT_CERT\n</code></pre> <ul> <li><code>issuer.csr</code> (in) - sent by PO issuer CA.</li> <li><code>intermediate_priv_key.pem</code> (in) - created by intermediate CA earlier.</li> <li><code>intermediate.crt</code> (in) - issued by root CA in response to request from   intermediate CA.</li> <li><code>issuer.crt</code> (out) - PO issuer CA certificate signed with   <code>intermediate_priv_key.pem</code>.</li> <li><code>issuer.ext</code> (in) - file describing certificate extensions, e.g.:</li> </ul> <pre><code>basicConstraints       = critical, CA:TRUE, pathlen:1\nkeyUsage               = critical, keyCertSign, cRLSign\nsubjectKeyIdentifier   = hash\nauthorityKeyIdentifier = keyid:always\n</code></pre>"},{"location":"keys_and_certificates/#putting-the-chain-together","title":"Putting the chain together","text":"<p>PEM files contain certificates (among other objects that are not relevant here) encoded as text. They can be concatenated e.g. with <code>cat</code> to form a chain. As mentioned above, the order of certificates matters: leaf (i.e. PO issuing certificate) must come first, root CA - last. Assuming <code>*.crt</code> files are PEM certificates of various CAs, full chain is produced by:</p> <pre><code>cat root.crt intermediate.crt issuer.crt &gt; cert_chain.pem\n</code></pre>"},{"location":"keys_and_certificates/#tldr-version","title":"TL;DR version","text":"<p>While it is strongly suggested to understand and follow steps described above, these steps can be used to produce a chain that will be accepted by Fobnail. It can be used to quickly build and test Fobnail project, but such approach defies the idea of Fobnail provisioning and Platform Owner in general. It should not be used on Tokens for production environments.</p> <ol> <li> <p>Create root CA key and certificate:</p> <pre><code>openssl req -newkey rsa:2048 -nodes -keyout root_ca_priv.pem -x509\n            -days 30 -out root_ca.crt -config &lt;(cat &lt;&lt; EOF\n\n[ req ]\ndistinguished_name     = req_distinguished_name\nprompt                 = no\nx509_extensions        = v3_ext\n\n[ req_distinguished_name ]\nC                      = PL\nO                      = Fobnail\nST                     = State\nCN                     = Platform Owner root CA certificate\n\n[v3_ext]\nbasicConstraints       = critical, CA:TRUE, pathlen:2\nkeyUsage               = critical, keyCertSign, cRLSign\nsubjectKeyIdentifier   = hash\nauthorityKeyIdentifier = keyid:always\n\nEOF\n)\n</code></pre> </li> <li> <p>Create PO issuing CA private key and CSR:</p> <pre><code>openssl req -newkey rsa:2048 -nodes -keyout po_priv_key.pem \\\n        -out issuer_ca.csr -config &lt;(cat &lt;&lt; EOF\n\n[ req ]\ndistinguished_name     = req_distinguished_name\nprompt                 = no\n\n[ req_distinguished_name ]\nC                      = PL\nO                      = Fobnail\nST                     = State\nCN                     = Platform Owner issuer CA certificate\n\nEOF\n)\n</code></pre> </li> <li> <p>Create PO issuing CA certificate:</p> <pre><code>openssl x509 -req -in issuer_ca.csr -CA root_ca.crt -CAcreateserial \\\n        -CAkey root_ca_priv.pem -days 30 -out issuer_ca.crt \\\n        -extfile &lt;(cat &lt;&lt; EOF\n\nbasicConstraints       = critical, CA:TRUE, pathlen:1\nkeyUsage               = critical, keyCertSign, cRLSign\nsubjectKeyIdentifier   = hash\nauthorityKeyIdentifier = keyid:always\n\nEOF\n)\n</code></pre> </li> <li> <p>Create chain from both certificates:</p> <pre><code>cat root_ca.crt issuer_ca.crt &gt; cert_chain.pem\n</code></pre> </li> </ol>"},{"location":"meta-fobnail-in-dlme/","title":"Running OS in DLME","text":"<p>In this document, we would like to describe the attempts to run a minimal operating system in the Dynamically Launched Measured Environment. For this purpose, we have prepared a meta-fobnail layer, which allows you to build a system image using the Yocto Project. Following this document will allow building an operating system running in DLME independently.</p>"},{"location":"meta-fobnail-in-dlme/#prerequisites","title":"Prerequisites","text":"<ul> <li>PC Engines apu2 with a serial connection to host PC</li> <li>Host PC that meets the requirements outlined in the Yocto Project   documentation   (tested on Ubuntu 20.04)</li> <li>At least 2GB USB stick to flash the image</li> <li>At least 2GB SD card and SD card reader</li> <li><code>bmaptools</code> installed; in case of Ubuntu it can be done via the following   command</li> </ul> <pre><code>sudo apt install bmap-tools\n</code></pre>"},{"location":"meta-fobnail-in-dlme/#background","title":"Background","text":"<p>To prepare a system that will be capable to run in DLME we want to use Trenchboot project. It is a framework that allows building security engines to perform launch integrity actions for their systems. The framework builds upon Boot Integrity Technologies (BITs) that establish one or more Roots of Trust (RoT) from which a degree of confidence that integrity actions were not subverted.</p> <p>Because we want to test on PC Engines apu2 we needed that our system consists of:</p> <ul> <li>GRUB SecureLaunch for   AMD</li> <li>Linux 5.13 SecureLaunch for Intel and   AMD</li> <li>Secure Kernel Loader</li> </ul> <p>The above information was obtained from the website describing the Trenchboot repositories.</p> <p>It is also crucial that the platform used for this test is PC Engines apu2 that runs at least coreboot <code>v4.12.0.3</code>. Other platforms with coreboot does not reserve memory for DRTM event log. The firmware can be found on pcengines.github.io.</p> <p>The last thing is to make sure that IOMMU is enabled. For PC Engines apu2 it can be checked in setup chosen from the boot menu.</p>"},{"location":"meta-fobnail-in-dlme/#building","title":"Building","text":"<p>As mentioned earlier, we prepared a project using Yocto. For layers management and simplification of the build process, we use kas tool with kas-container script. All build components are open and public, so everyone can try to reproduce our effort if only the prerequisites are met.</p>"},{"location":"meta-fobnail-in-dlme/#instructions","title":"Instructions","text":"<p>To complete the build process, please execute the following steps.</p> <ol> <li>Download <code>kas-container</code> script, place it in PATH</li> </ol> <pre><code>$ wget https://raw.githubusercontent.com/siemens/kas/2.6.2/kas-container ~/bin/kas-container\n</code></pre> <ol> <li>Make it executable.</li> </ol> <pre><code>$ chmod +x ~/bin/kas-container\n</code></pre> <ol> <li>Make sure that script can be executed from any place.</li> </ol> <pre><code>$ kas-container --help\nUsage: /home/tomzy/bin/kas-container [OPTIONS] { build | checkout | shell } [KASOPTIONS] [KASFILE]\n       /home/tomzy/bin/kas-container [OPTIONS] for-all-repos [KASOPTIONS] [KASFILE] COMMAND\n       /home/tomzy/bin/kas-container [OPTIONS] clean\n       /home/tomzy/bin/kas-container [OPTIONS] menu [KCONFIG]\n\nPositional arguments:\nbuild                   Check out repositories and build target.\ncheckout                Check out repositories but do not build.\nshell                   Run a shell in the build environment.\nfor-all-repos           Run specified command in each repository.\nclean                   Clean build artifacts, keep downloads.\nmenu                    Provide configuration menu and trigger configured build.\n\nOptional arguments:\n--isar                  Use kas-isar container to build Isar image.\n--with-loop-dev         Pass a loop device to the container. Only required if\n                        loop-mounting is used by recipes.\n--runtime-args          Additional arguments to pass to the container runtime\n                        for running the build.\n--docker-args           Same as --runtime-args (deprecated).\n-d                      Print debug output.\n-v                      Same as -d (deprecated).\n--version               print program version.\n--ssh-dir               Directory containing SSH configurations.\n                        Avoid $HOME/.ssh unless you fully trust the container.\n--aws-dir               Directory containing AWScli configuration.\n--git-credential-store  File path to the git credential store\n--no-proxy-from-env     Do not inherit proxy settings from environment.\n--repo-ro               Mount current repository read-only\n                        (default for build command)\n--repo-rw               Mount current repository writeable\n                        (default for shell command)\n\nYou can force the use of podman over docker using KAS_CONTAINER_ENGINE=podman.\n</code></pre> <ol> <li>Clone <code>meta-fobnail</code> repository.</li> </ol> <pre><code>$ git clone git@github.com:fobnail/meta-fobnail.git\n</code></pre> <p>Note: use <code>git clone https://github.com/fobnail/meta-fobnail.git</code> if do not   have SSH keys in GitHub account.</p> <ol> <li>Start build.</li> </ol> <pre><code>$ kas-container build meta-fobnail/kas-debug.yml\n</code></pre> <p>Note: <code>kas-debug.yml</code> configuration will generate a debug version of the   image, which differs from prod in that it does not have a root password</p> <p>Running this command will clone every needed Yocto layer and start the build which last about 2 hours for the first run.</p> <ol> <li>Flash image.</li> </ol> <p>Firstly, you need to connect your USB stick to your PC and unmount the device.</p> <pre><code>$ sudo fdisk -l\n\nDevice     Boot   Start      End Sectors Size Id Type\n/dev/sdb1  *       2048    34815   32768  16M  c W95 FAT32 (LBA)\n/dev/sdb2         34816  2131967 2097152   1G 83 Linux\n/dev/sdb3       2131968  4229119 2097152   1G 83 Linux\n/dev/sdb4       4229120 12617727 8388608   4G 83 Linux\n\n$ sudo umount /dev/sdX*  # in this case /dev/sdb*\n</code></pre> <p>Now you can flash your image.</p> <pre><code>$ cd build/tmp/deploy/images/fobnail-machine\n$ sudo bmaptool copy --bmap fobnail-base-image-debug-fobnail-machine.wic.bmap \\\n  fobnail-base-image-debug-fobnail-machine.wic.gz /dev/sdX # in this case /dev/sdb\n</code></pre>"},{"location":"meta-fobnail-in-dlme/#tests","title":"Tests","text":"<p>We checked a couple of configurations to run our minimal OS in DLME. It is essential to build GRUB, Linux kernel, and Secure Kernel Loader in such a form that they can work together, which will allow us to achieve our goal. For most cases, we want to load the following configuration with GRUB.</p> <pre><code>menuentry 'secure-boot'{\n  slaunch skinit\n  slaunch_module (hd0,msdos1)/skl.bin\n  linux /bzImage root=/dev/sda2 console=ttyS0,115200 earlyprintk=serial,ttyS0,115200\n}\n</code></pre>"},{"location":"meta-fobnail-in-dlme/#test-of-latest-trenchboot","title":"Test of latest Trenchboot","text":"<p>In the beginning, we prepared a build containing the revisions mentioned on the Trenchboot website. They are listed in the background section. Such an image can be built by following the steps described in the instructions section. The only difference is that the meta-fobnail repository should be checked out to <code>tb-latest-bad-format</code> branch.</p> <p>Unfortunately, the boot failed and reset while the platform was still in GRUB. The result was as follows.</p> <pre><code>grub_cmd_slaunch:122: check for manufacturer\ngrub_cmd_slaunch:126: check for cpuid\ngrub_cmd_slaunch:136: set slaunch\ngrub_cmd_slaunch_module:156: check argc\ngrub_cmd_slaunch_module:161: check relocator\ngrub_cmd_slaunch_module:170: open file\ngrub_cmd_slaunch_module:175: get size\ngrub_cmd_slaunch_module:180: allocate memory\ngrub_cmd_slaunch_module:192: addr: 0x100000\ngrub_cmd_slaunch_module:194: target: 0x100000\ngrub_cmd_slaunch_module:196: add module\ngrub_cmd_slaunch_module::205: read file\ngrub_cmd_slaunch_module:215: close file\ngrub_slaunch_boot_skinit:41: real_mode_target: 0x8b000\ngrub_slaunch_boot_skinit:42: prot_mode_target: 0xx1000000\ngrub_slaunch_boot_skinit:43: params: 0xcfe037cBad bootloader data format\nRebooting now..\n</code></pre>"},{"location":"meta-fobnail-in-dlme/#3mdeb-grub-fork","title":"3mdeb GRUB fork","text":"<p>Problems early in booting meant we needed to make some modifications to GRUB. To test the next build, repeat the steps in the instructions using the branch <code>tb-grub-3mdeb</code>.</p> <p>Compared to the previous configuration, we used the 3mdeb fork for GRUB here. The Secure Kernel Loader on master already uses passing info via MB2 tags. TrenchBoot/GRUB lacks it.</p> <p>We were able to push the boot further, but not much further though. The result was as follows. SKL falls into an endless loop (the observed <code>Flushing IOMMU cache</code> log will be printed indefinitely).</p> <pre><code>shasum calculated:\n0x001001dc: e5 7d 2d 07 37 2b 7e 38 ec f7 d4 52 72 c9 6d 63   .}-.7+~8...Rr.mc\n0x001001ec: 9e 52 83 76 cc cc cc cc cc cc cc cc cc cc cc cc   .R.v............\nshasum calculated:\n0x001001f0: 7f dd 92 0a 8c 39 1b 4c 76 ee 1c 31 43 a8 55 9e   .....9.Lv..1C.U.\n0x00100200: 6a 6a 41 8f d4 10 17 87 27 fd ea b9 dc d6 57 6a   jjA.....'.....Wj\nPCR extended\nIOMMU MMIO Base Address = 0xf7f00000:\n0x00000000: IOMMU_MMIO_STATUS_REGISTER\n0x00106001: IOMMU_MMIO_DEVICE_TABLE_BA\n0x00103000: IOMMU_MMIO_COMMAND_BUF_BA\n0x00105000: IOMMU_MMIO_EVENT_LOG_BA\n0x00000018: IOMMU_MMIO_STATUS_REGISTER\nINVALIDATE_IOMMU_ALL\n0x00290ad2: IOMMU_MMIO_EXTENDED_FEATURE\n0x0000000a: IOMMU_MMIO_STATUS_REGISTER\n0x0000000a: IOMMU_MMIO_STATUS_REGISTER\nDisabling SLB protection\nIOMMU MMIO Base Address = 0xf7f00000:\n0x0000000a: IOMMU_MMIO_STATUS_REGISTER\n0x00106001: IOMMU_MMIO_DEVICE_TABLE_BA\n0x00103000: IOMMU_MMIO_COMMAND_BUF_BA\n0x00105000: IOMMU_MMIO_EVENT_LOG_BA\n0x0000001a: IOMMU_MMIO_STATUS_REGISTER\nINVALIDATE_IOMMU_ALL\n0x00290ad2: IOMMU_MMIO_EXTENDED_FEATURE\n0x0000000a: IOMMU_MMIO_STATUS_REGISTER\n0x0000000a: IOMMU_MMIO_STATUS_REGISTER\nFlushing IOMMU cache..........................................................\n</code></pre>"},{"location":"meta-fobnail-in-dlme/#wa-patch-for-skl","title":"W/A patch for SKL","text":"<p>We can solve the above problem with IOMMU in one of two ways:</p> <ul> <li>turn off the IOMMU in PC Engines apu2 (which we do not want to do),</li> <li>add a small workaround for the Secure Kernel Loader.</li> </ul> <p>We decided to implement the second option and add the following change into the SKL source code.</p> <pre><code>Subject: [PATCH] main.c: IOMMU flushing infinity loop workaround\n\n---\n main.c | 7 ++++---\n 1 file changed, 4 insertions(+), 3 deletions(-)\n\ndiff --git a/main.c b/main.c\nindex d2c727a..d125fa6 100644\n--- a/main.c\n+++ b/main.c\n@@ -341,9 +341,10 @@ static void iommu_setup(void)\n\n                iommu_load_device_table(iommu_cap, &amp;iommu_done);\n                print(\"Flushing IOMMU cache\");\n-               while (!iommu_done) {\n-                       print(\".\");\n-               }\n+               /* Inifnity loop workaround */\n+               //while (!iommu_done) {\n+                       //print(\".\");\n+               //}\n                print(\"\\nIOMMU set\\n\");\n        }\n\n--\n2.25.1\n</code></pre> <p>It helped us to go even further. To test this changes, repeat the steps in the instructions using the branch <code>tb-grub-3mdeb-iommu</code>. The start was promising.</p> <pre><code>shasum calculated:\n0x001001dc: 44 b6 98 d6 93 b8 5b 21 9b 87 0a 43 a9 bf 27 af   D.....[!...C..'.\n0x001001ec: 8f 58 b7 35 cc cc cc cc cc cc cc cc cc cc cc cc   .X.5............\nshasum calculated:\n0x001001f0: 4a 9d bd 0c 02 b0 fb 79 c5 79 8a 53 2a 67 eb f7   J......y.y.S*g..\n0x00100200: 91 8b 3d 87 6f cb db 03 08 c3 cb 27 f1 92 c4 f4   ..=.o......'....\nPCR extended\nIOMMU MMIO Base Address = 0xf7f00000:\n0x00000000: IOMMU_MMIO_STATUS_REGISTER\n0x00106001: IOMMU_MMIO_DEVICE_TABLE_BA\n0x00103000: IOMMU_MMIO_COMMAND_BUF_BA\n0x00105000: IOMMU_MMIO_EVENT_LOG_BA\n0x00000018: IOMMU_MMIO_STATUS_REGISTER\nINVALIDATE_IOMMU_ALL\n0x00290ad2: IOMMU_MMIO_EXTENDED_FEATURE\n0x0000000a: IOMMU_MMIO_STATUS_REGISTER\n0x0000000a: IOMMU_MMIO_STATUS_REGISTER\nDisabling SLB protection\nIOMMU MMIO Base Address = 0xf7f00000:\n0x0000000a: IOMMU_MMIO_STATUS_REGISTER\n0x00106001: IOMMU_MMIO_DEVICE_TABLE_BA\n0x00103000: IOMMU_MMIO_COMMAND_BUF_BA\n0x00105000: IOMMU_MMIO_EVENT_LOG_BA\n0x0000001a: IOMMU_MMIO_STATUS_REGISTER\nINVALIDATE_IOMMU_ALL\n0x00290ad2: IOMMU_MMIO_EXTENDED_FEATURE\n0x0000000a: IOMMU_MMIO_STATUS_REGISTER\n0x0000000a: IOMMU_MMIO_STATUS_REGISTER\nFlushing IOMMU cache\nIOMMU set\n\ncode32_start 0x01000000:\nmle_header\n0x01000514: 5a ac 82 90 6f 47 a7 74 0f 5c 55 a2 cb 51 b6 42   Z...oG.t.\\U..Q.B\n0x01000524: 34 00 00 00 02 00 02 00 a0 9c 89 00 00 00 00 00   4...............\n0x01000534: 00 00 00 00 34 3f 8a 00 27 02 00 00 00 00 00 00   ....4?..'.......\n0x01000544: 00 00 00 00 1f 8b 08 00 00 00 00 00 02 03 ec dd   ................\nshasum calculated:\n0x001001dc: 2e aa bb 1b 57 52 6c cf 6a 44 4c 3b ed 31 49 19   ....WRl.jDL;.1I.\n0x001001ec: c5 78 58 ba 34 3a 20 00 93 12 10 00 00 00 00 00   .xX.4: .........\nshasum calculated:\n0x001001f0: a6 cd 2c aa c9 34 d6 cf 7b 44 de 87 43 04 33 54   ..,..4..{D..C.3T\n0x00100200: 27 70 1c d7 80 97 7a 5e f7 7a 42 50 93 8b 7f 3f   'p....z^.zBP...?\nPCR extended\n</code></pre> <p>But unfortunately, we failed to boot, and the process ended with <code>slaunch: Error failed to find TPM event log</code> error.</p> <pre><code>[    3.998124] slaunch: Error failed to find TPM event log\n[    3.998124]  - error: 0xc0008022\n[    3.998209] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n[    3.999030] CPU: 1 PID: 1 Comm: swapper/0 Not tainted 5.13.0-yocto-standard #1\n[    3.999030] Hardware name: PC Engines apu2/apu2, BIOS v4.12.0.3 07/30/2020\n[    3.999030] RIP: 0010:slaunch_skinit_reset+0x1b/0x1d\n[    3.999030] Code: c7 c8 f6 df af e8 10 74 00 00 e9 89 14 4e ff 0f 1f 44 00 00 55 48 89 f2 48 89 fe 48 c7 c7 74 f8 df af 48 89 e5 e8 f0 73 00 00 &lt;0f&gt; 0b 83 c8 03 48 c7 c7 e0 f7 df af 89 05 e9 de c9 00 e8 d9 73 00\n[    3.999030] RSP: 0018:ffffb7ed40023e50 EFLAGS: 00010246\n[    3.999030] RAX: 0000000000000040 RBX: 0000000000000000 RCX: 0000000000000000\n[    3.999030] RDX: 0000000000000000 RSI: 00000000ffffffea RDI: 00000000ffffffff\n[    3.999030] RBP: ffffb7ed40023e50 R08: ffffffffb00c17e8 R09: 0000000000000003\n[    3.999030] R10: ffffffffb0051800 R11: ffffffffb0051800 R12: ffffffffb0270f67\n[    3.999030] R13: ffff9bc980160b40 R14: ffffffffb03b1384 R15: 0000000000000000\n[    3.999030] FS:  0000000000000000(0000) GS:ffff9bc9aac80000(0000) knlGS:0000000000000000\n[    3.999030] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[    3.999030] CR2: 0000000000000000 CR3: 000000005d80a000 CR4: 00000000000406e0\n[    3.999030] Call Trace:\n[    3.999030]  slaunch_module_init+0x40d/0x501\n[    3.999030]  ? slaunch_setup_txt+0x4f4/0x4f4\n[    3.999030]  do_one_initcall+0x51/0x220\n[    3.999030]  kernel_init_freeable+0x1f2/0x241\n[    3.999030]  ? rest_init+0xc3/0xc3\n[    3.999030]  kernel_init+0xe/0x10d\n[    3.999030]  ret_from_fork+0x22/0x30\n[    3.999030] Modules linked in:\n[    4.144594] ---[ end trace 6340ff4ba3dd3afb ]---\n[    4.149263] RIP: 0010:slaunch_skinit_reset+0x1b/0x1d\n[    4.154348] Code: c7 c8 f6 df af e8 10 74 00 00 e9 89 14 4e ff 0f 1f 44 00 00 55 48 89 f2 48 89 fe 48 c7 c7 74 f8 df af 48 89 e5 e8 f0 73 00 00 &lt;0f&gt; 0b 83 c8 03 48 c7 c7 e0 f7 df af 89 05 e9 de c9 00 e8 d9 73 00\n[    4.173123] RSP: 0018:ffffb7ed40023e50 EFLAGS: 00010246\n[    4.178364] RAX: 0000000000000040 RBX: 0000000000000000 RCX: 0000000000000000\n[    4.185507] RDX: 0000000000000000 RSI: 00000000ffffffea RDI: 00000000ffffffff\n[    4.192697] RBP: ffffb7ed40023e50 R08: ffffffffb00c17e8 R09: 0000000000000003\n[    4.199841] R10: ffffffffb0051800 R11: ffffffffb0051800 R12: ffffffffb0270f67\n[    4.206992] R13: ffff9bc980160b40 R14: ffffffffb03b1384 R15: 0000000000000000\n[    4.214142] FS:  0000000000000000(0000) GS:ffff9bc9aac80000(0000) knlGS:0000000000000000\n[    4.222261] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[    4.228021] CR2: 0000000000000000 CR3: 000000005d80a000 CR4: 00000000000406e0\n[    4.235214] Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b\n[    4.236170] Kernel Offset: 0x2dc00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n[    4.236170] ---[ end Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b ]---\n</code></pre> <p>Full boot log can be found in meta-fobnail-log.cap.</p>"},{"location":"meta-fobnail-in-dlme/#working-solution","title":"Working solution","text":"<p>Unfortunately, we had to make a few concessions to get our system running in DLME. Instead of SKL, we used a landing zone, we had to replace the kernel with an older version (v5.8), and we had to turn off IOMMU in the platform options. Ultimately, we used the following components for the build.</p> <ul> <li>GRUB:   3mdeb fork and branch <code>tpm_event_log_support</code></li> <li>kernel:   version v5.8, branch <code>linux-sl-5.8amd</code></li> <li>landing-zone:   instead of Secure Kernel Loader from TrenchBoot</li> </ul> <p>Update: Since v0.2.2 we managed to use latest versions of GRUB and kernel as   well as the Secure Kernel Loader instead of landing-zone. The system now   starts with IOMMU turned on. We needed the following revisions/versions</p> <ul> <li>GRUB</li> <li>kernel</li> <li>SKL     with reverted changes from IOMMU: Shrink the size of the command     buffer</li> </ul> <p>In addition, we also had to give up trying to boot our system from a USB stick and switch to booting from a SD card. Unfortunately, after the LZ application, the system was unable to detect the USB device while booting. Eventually we loaded the following configuration into GRUB.</p> <pre><code>menuentry 'secure-boot'{\n  slaunch skinit\n  slaunch_module (hd0,msdos1)/lz_header.bin\n  linux /bzImage root=/dev/mmcblk0p2 console=ttyS0,115200 earlyprintk=serial,ttyS0,115200\n}\n</code></pre> <p>Update: Since v0.2.2 we use here skl.bin file instead of lz_header.bin.</p> <p>Using the above, we can boot into a system for which we assume it runs in DLME. In the later stages of the project, we will add to the system appropriate tools to check the content of PCR17 and PCR18, which will allow us to confirm this fact. To test this build, repeat the steps in the instructions. The changes are merged to <code>main</code> branch.</p> <p>Update: Since v0.1.1 after login to shell, we can run <code>tpm2_pcrread</code> to verify   PCR17 and PCR18 values. If these registers are not empty (or equal to   0xFFFF...), we can conclude that the device is running in DLME. The output of   PCR registers dump should look similar to this:</p> <pre><code># tpm2_pcrread\nsha1:\n  0 : 0x3A3F780F11A4B49969FCAA80CD6E3957C33B2275\n  1 : 0xE3B26DA646504EF1E716C2D2B6DE920EA37F919D\n  2 : 0x53DE584DCEF03F6A7DAC1A240A835893896F218D\n  3 : 0x3A3F780F11A4B49969FCAA80CD6E3957C33B2275\n  4 : 0x29E503140459F9AE7B6FB502AB0486D941DE948C\n  5 : 0x6A0AEEB558ECFBCB56A13C2E525D511412C1B558\n  6 : 0x3A3F780F11A4B49969FCAA80CD6E3957C33B2275\n  7 : 0x3A3F780F11A4B49969FCAA80CD6E3957C33B2275\n  8 : 0x0000000000000000000000000000000000000000\n  9 : 0x0000000000000000000000000000000000000000\n  10: 0x0000000000000000000000000000000000000000\n  11: 0x0000000000000000000000000000000000000000\n  12: 0x0000000000000000000000000000000000000000\n  13: 0x0000000000000000000000000000000000000000\n  14: 0x0000000000000000000000000000000000000000\n  15: 0x0000000000000000000000000000000000000000\n  16: 0x0000000000000000000000000000000000000000\n  17: 0x79827B00FE723A9CDADC1A88AC564F73762752D9\n  18: 0x6095E1C7DF27260720C3C73585C8B2C61765E7FD\n  19: 0x0000000000000000000000000000000000000000\n  20: 0x0000000000000000000000000000000000000000\n  21: 0x0000000000000000000000000000000000000000\n  22: 0x0000000000000000000000000000000000000000\n  23: 0x0000000000000000000000000000000000000000\nsha256:\n  0 : 0xD27CC12614B5F4FF85ED109495E320FB1E5495EB28D507E952D51091E7AE2A72\n  1 : 0xCAC0A9141FA63BCB0027B4C219E9DC19CE164EBB003297D3F2F1AF1877B561D8\n  2 : 0xFA8791BB6BCE8EBF4AD7B516ADFBBB9B2F1499A8876E2C909135AEBDCCA2D84C\n  3 : 0xD27CC12614B5F4FF85ED109495E320FB1E5495EB28D507E952D51091E7AE2A72\n  4 : 0xA7862EE52AA91BFFFBA8E04B7D2EA8660ABFAA610F8B831A2701F03DF9E33493\n  5 : 0x0DE1E8677D23636EFBDADEA31E697A862386309383800A8DA695D1E1D4F8D60B\n  6 : 0xD27CC12614B5F4FF85ED109495E320FB1E5495EB28D507E952D51091E7AE2A72\n  7 : 0xD27CC12614B5F4FF85ED109495E320FB1E5495EB28D507E952D51091E7AE2A72\n  8 : 0x0000000000000000000000000000000000000000000000000000000000000000\n  9 : 0x0000000000000000000000000000000000000000000000000000000000000000\n  10: 0x0000000000000000000000000000000000000000000000000000000000000000\n  11: 0x0000000000000000000000000000000000000000000000000000000000000000\n  12: 0x0000000000000000000000000000000000000000000000000000000000000000\n  13: 0x0000000000000000000000000000000000000000000000000000000000000000\n  14: 0x0000000000000000000000000000000000000000000000000000000000000000\n  15: 0x0000000000000000000000000000000000000000000000000000000000000000\n  16: 0x0000000000000000000000000000000000000000000000000000000000000000\n  17: 0xADB1DB1E9EE753FF66EF9AB06BC2192FDAB24C4239F06AA37B5B8D8ECE0A2294\n  18: 0xD73B0CA75F4323BC7C7A7397580336096974468114C25CA4CA89E3991CC4634D\n  19: 0x0000000000000000000000000000000000000000000000000000000000000000\n  20: 0x0000000000000000000000000000000000000000000000000000000000000000\n  21: 0x0000000000000000000000000000000000000000000000000000000000000000\n  22: 0x0000000000000000000000000000000000000000000000000000000000000000\n  23: 0x0000000000000000000000000000000000000000000000000000000000000000\n</code></pre>"},{"location":"meta-fobnail-in-dlme/#summary","title":"Summary","text":"<ul> <li>When we started working on this issue, we assumed that we would be able to run   a minimal OS in DLME by integrating the latest revisions of <code>Trenchboot</code>   components in it; unfortunately, we encountered some problems that may be   possible to solve together.</li> <li>At the moment, we have agreed to a satisfactory solution; the later stages of   the project will allow us to confirm that the OS is running in DLME.</li> <li>To start a discussion of the problems we encountered when trying to integrate   <code>Trenchboot</code> into PC Engines apu2, we created an   issue</li> </ul>"},{"location":"meta-fobnail-in-dlme/#update","title":"Update","text":"<ul> <li>As proved in previous section, we managed to run latest version of SKL, and   solve the   issue</li> </ul>"},{"location":"minimal-os-for-fobnail/","title":"Minimal OS for Fobnail Project","text":"<p>The Fobnail Project aims to build a USB device capable of verifying trustworthiness of the platform it is connected to. The project is described more in-depth here.</p> <p>According to the information presented at TrenchBoot Summit 2021 Fobnail: Attestation in Your Pocket, the minimum OS, together with the connected Fobnail Token, should allow determining the state of the platform before the target OS is launched. As we can see in the presentation, heads (here presented as a coreboot payload) could be responsible for the platform's trust control. But in this document, we want to present the results of research on the possibilities of using various operating systems running as DLME that will perform the same function.</p> <p>Also it should be possible to launch minimal OS from an already running target OS, this is called late launch as opposed to early launch described above. Minimal OS would communicate with Fobnail Token, perform attestation in order to determine platform state, and then hand the control back to the main OS. Currently, only early launch will be supported, late launch is planned as a future improvement.</p>"},{"location":"minimal-os-for-fobnail/#os-requirements","title":"OS requirements","text":"<p>We pay attention to the drivers supported by each OS. We need the following drivers:</p> <ul> <li>TPM drivers</li> <li>Drivers required for communicating with Fobnail Token:</li> <li>USB host drivers - at minimum EHCI and xHCI support, however UHCI and OHCI     would be good to have</li> <li>USB EEM driver - emulated Ethernet driver</li> <li>network stack with IPv4 support</li> </ul> <p>Also we pay attention to OS security, ability to run in DLME, including portability between different hardware (a single binary should be able to boot on all x86 platforms with support for ACPI) and ability to chainload another, target OS.</p> <p>The table below summarises OS features which are a hard requirement, though they could be implemented by us.</p> Requirement Description USB host driver Required for communication with Fobnail Token USB EEM driver Required for communication with Fobnail Token Network Stack Required for communication with Fobnail Token TPM driver Required to perform attestation Bootloader Capabilities Required to boot target OS C library Fobnail Attester is writen in C Bootable by SKL Whether OS can be loaded by TrenchBoot SKL without SKL or OS modification License Whether OS use open-source license, and if licese used is applicable for embedded market <p>These are another features which are taken into account (soft requirements).</p> Feature Description Microkernel Microkernels are more secure and are preferred OS portability Required to avoid rebuilding minimal OS for each device CPU Architecture support OS supported architectures, mostly we consider x86, ARM, RISC-V and POWER"},{"location":"minimal-os-for-fobnail/#different-oss-propositions","title":"Different OSs propositions","text":"<p>The research effect is presented below. 8 systems were considered</p> <ul> <li>Zephyr</li> <li>Xous</li> <li>seL4 (with and without CAmkES)</li> <li>Genode</li> <li>Linux</li> <li>Little Kernel / Trusted Little Kernel</li> <li>Fuchsia</li> <li>Xen</li> </ul> <p>Each of them has a short description, an analysis of the launch in DLME, and the possibilities and potential problems that will have to be addressed for the Fobnail Token to be functional.</p>"},{"location":"minimal-os-for-fobnail/#zephyr","title":"Zephyr","text":"<p>Zephyr is a well-known and supported embedded RTOS with a monolithic kernel written in C. It supports various devices ranging from Cortex-M to x86 CPUs. It's main benefits are IPv4, CoAP, and USB (including USB EEM) support which are required for communication with Fobnail Token. Other benefits are listed here.</p>"},{"location":"minimal-os-for-fobnail/#running-in-dlme","title":"Running in DLME","text":"<p>Secure launch uses a component called SKL (Secure Kernel Loader) which is responsible for booting OS in DLME (Zephyr in that case). Zephyr boots using Multiboot1 but SKL does not support it (only Multiboot2 is supported). For SKL to be able to boot Zephyr, Zephyr must gain Multiboot2 support.</p> <p>Multiboot1 is hard to measure due to its tags being scattered around in memory. To properly measure Multiboot1, SKL would have to know and parse every tag as most of them contain pointers to other structures. This is not going to happen.</p> <p>Also, Zephyr may have trouble with running on different hardware configurations. Some important HW-related configuration is baked into Zephyr during build:</p> <ul> <li> <p>LAPIC base is selected by <code>CONFIG_LOAPIC_BASE_ADDRESS</code>, if target platform has   LAPIC remapped using <code>IA32_APIC_BASE</code> Zephyr will break.</p> </li> <li> <p>APIC mode (xAPIC vs x2APIC) is selected when building Zephyr and cannot be   detected at runtime. Zephyr may not boot if it has different APIC mode set   than firmware has.</p> </li> </ul> <p>As part of the PoC tests, the possibility of using Zephyr as a minimum OS running in DLME was checked. The results are described here.</p>"},{"location":"minimal-os-for-fobnail/#fobnail-integration","title":"Fobnail integration","text":"<p>Zephyr provides most of the drivers needed for integration:</p> <ul> <li>USB hub drivers,</li> <li>USB EEM driver,</li> <li>Network stack with IPv4 and CoAP support.</li> </ul> <p>TPM driver is missing, there is a fairly recent PoC implementation of TPM2 stack, but it is intended for embedded devices and supports SPI only.</p> <p>Zephyr provides good support for standard C library (newlib), which should simplify Fobnail Attester porting.</p>"},{"location":"minimal-os-for-fobnail/#license","title":"License","text":"<p>Basically runs under GPLv2 License but more information can be found here.</p>"},{"location":"minimal-os-for-fobnail/#xous","title":"Xous","text":"<p>Xous is a microkernel-based OS written in Rust, currently in Alpha state. Xous is used as a secure microkernel for Betrusted device and is focused on RISC-V, which right now is the only architecture supported. However, x86 already contains dummy implementation which probably will be extended someday.</p>"},{"location":"minimal-os-for-fobnail/#running-in-dlme_1","title":"Running in DLME","text":"<p>Xous currently cannot run on x86, and DLME on RISC-V is not covered here. We have opened an issue raising the subject, among others, about x86 support.</p>"},{"location":"minimal-os-for-fobnail/#fobnail-integration_1","title":"Fobnail integration","text":"<p>Xous has network support but currently lacks USB host drivers and TPM support. Also, it lacks C interface for calling the kernel and lacks C library. This should not be a serious problem and may be solved by rewriting Fobnail Attester in Rust or by adding required C bindings to Rust code. It means that getting Fobnail Attester running may require some amount of work. Also, Xous needs to gain kexec-like abilities to chainload target OS.</p>"},{"location":"minimal-os-for-fobnail/#license_1","title":"License","text":"<p>The Xous microkernel runs under Apache 2.0 license.</p>"},{"location":"minimal-os-for-fobnail/#sel4","title":"seL4","text":"<p>seL4 is a secure L4 family microkernel written in C. It has strong security guarantees assured by formal proofs. However these proofs are still incomplete for x86; see Supported Platforms for an up-to-date verification status. Due to its microkernel nature, seL4 provides stronger isolation. A breach in one of the components (such as a USB driver or the network stack) wouldn't compromise the entire OS (contrary to monolithic kernels).</p> <p>We have opened an issue about seL4 usage as secure bootloader.</p>"},{"location":"minimal-os-for-fobnail/#running-in-dlme_2","title":"Running in DLME","text":"<p>It should be runnable, however due to microkernel nature all programs run in unprivileged mode which complicates booting of the target OS. seL4 would have to gain kexec-like abilities. seL4 developers are willing to add kexec support.</p>"},{"location":"minimal-os-for-fobnail/#fobnail-integration_2","title":"Fobnail integration","text":"<p>seL4 provides virtually no drivers, except a few drivers listed here. According to the page linked above, <code>libusbdrivers</code> is inactive and lacks XHCI support. seL4 has basic support for an old version of musl C library (v1.1.16).</p> <p>Using seL4 would require a significant amount of work:</p> <ul> <li>Extending USB drivers,</li> <li>Implementing USB EEM driver,</li> <li>Implementing TPM driver,</li> <li>Porting Fobnail Attester,</li> <li>seL4 runs all processes in unprivileged mode, so the kernel itself would have   to be modified to allow booting of another kernel.</li> </ul> <p>Genode can provide many of the required drivers. See the section below for details.</p> <p>CAmkES provides tools for writing seL4-native components, it also has VMM support for running virtual machines. Contrary to Genode CAmkES does not provide drivers, but VMs may provide them. However this requires virtualization and seL4 currently supports it only on Intel CPUs. See the section below for more details.</p>"},{"location":"minimal-os-for-fobnail/#license_2","title":"License","text":"<p>The documentation shows that the seL4 kernel itself and most of its proof is licensed under GPL Version 2.</p>"},{"location":"minimal-os-for-fobnail/#genode","title":"Genode","text":"<p>Genode is a framework for creating custom, specialized OSes. It can work on various kernels/hypervisors, including seL4 and Linux. It provides many drivers, including USB drivers (including <code>usb-net</code> driver which should handle USB EEM) and a network stack. When running on Linux all components are sandboxed with seccomp, however it should be noted that Linux drivers are used. For other kernels Genode provides sandboxed drivers.</p>"},{"location":"minimal-os-for-fobnail/#running-in-dlme_3","title":"Running in DLME","text":"<p>Whether Genode can run in DLME depends on the choosen kernel, however we are interested mainly in seL4. Please see seL4 section above for details.</p>"},{"location":"minimal-os-for-fobnail/#fobnail-integration_3","title":"Fobnail integration","text":"<p>TPM driver would have to be ported to Genode. Underlying kernel must have kexec abilities and Genode must have component capable of invoking kexec. USB and EEM drivers should work out-of-the-box.</p> <p>Genode's seL4 support is considered to be in healthly state (see this comment). But it should be noted Genode with seL4 has not been used outside the lab so far.</p>"},{"location":"minimal-os-for-fobnail/#license_3","title":"License","text":"<p>Genode license (AGPLv3) is very restrictive and it could be a problem for the Fobnail Project.</p>"},{"location":"minimal-os-for-fobnail/#sel4-camkes","title":"seL4 + CAmkES","text":"<p>CAmkES provides tools and libraries for quickly writing seL4-native components. Contrary to <code>seL4_libs</code> CAmkES is planned to be formally verified (verification is in progress).</p>"},{"location":"minimal-os-for-fobnail/#running-in-dlme_4","title":"Running in DLME","text":"<p>Since CAmkES is based on seL4, the same restrictions apply. See the section above for details.</p>"},{"location":"minimal-os-for-fobnail/#fobnail-integration_4","title":"Fobnail integration","text":"<p>CAmkES also does not provide many drivers. However it does provide VMM for virtual machines. Features:</p> <ul> <li>Support for booting Linux kernel.</li> <li>Support only for 32-bit VMs, according to   camkes-vm documentation. <p>The first step is to install Ubuntu natively on the cma34cr. It\u2019s currently required that guests of the camkes-vm run in 32-bit mode, so install 32-bit Ubuntu.</p> </li> <li>Support for hardware passthrough, however it is severely limited and it   requires manual configuration, including IO port assignment, memory mapping,   interrupts setup. This is completely not portable and cannot be used in this   form. Normally, VM config is written in CAmkES specific language, which is   processed during build. VM config cannot be generated at runtime making robust   HW passthrough impossible.</li> <li>Lack of support for AMD-V. Until this is implemented there is no   virtualization on AMD CPUs.</li> </ul> <p>We expect some of these limitations to be fixed by the Makatea project, which aims at creating a Qubes-like OS on top of seL4.</p> <p>If CAmkES had good enough virtualization we could take the following approach to build secure OS for running Fobnail Attester:</p> <ul> <li>Fobnail Attester would have to be split into 2 parts: part that communicates   with Fobnail Token through network and a separate part called secure   component.</li> <li>Secure component would be a program running natively under microkernel and it   would be responsible for:</li> <li>Loading next stage OS into RAM (disk drivers would be located in Linux VM)     and extending PCRs early during minimal OS startup.</li> <li>Starting Fobnail Attester in Linux.</li> <li>Acting as a proxy between Fobnail Attester and TPM - only operations     required to perform platform provisioning/attestation like TPM quote,     reading EK certificate, etc. (this must be a minimal component providing     only the most basic set of features, it must be verified that it has no     exploitable bugs)</li> <li>Secure component would be responsible for booting target OS after attestation   is successful.</li> </ul> <p>With this approach, even if VM got compromised it wouldn't break attestation. Linux VM can't boot another OS, it can only signal secure component to boot the exact OS that has been loaded earlier and nothing more. We avoid a situation when compromised VM performs successful attestation but boots something else.</p> <p>Also, it could be possible to use Rump kernels instead of Linux VM. Rump is a library kernel capable of running unmodified Netbsd drivers. Usually it is used in Netbsd to test drivers in userspace, however it has been used before to provide drivers for other kernels through the Rumprun project. Please note that it is unikernel which is intended to run in VM, but Rump itself (theoretically) could be adapted to run as CAmkES/seL4 component, eliminating the need for VM.</p>"},{"location":"minimal-os-for-fobnail/#license_4","title":"License","text":"<p>In case of <code>CAmkES</code> we can verify the licenses by checking LICENSE document on the project repository. It uses standard open source licenses.</p>"},{"location":"minimal-os-for-fobnail/#linux","title":"Linux","text":"<p>In the case of Linux, a minimal distribution will be prepared that meets the requirements of the Fobnail Project. Yocto Project will be used for this, because it gives a lot of freedom in manipulating the elements that make up the target system.</p>"},{"location":"minimal-os-for-fobnail/#running-in-dlme_5","title":"Running in DLME","text":"<p>Ensuring that the operating system works in DLME can be achieved by using the TrenchBoot project. For this purpose, a Yocto meta-fobnail layer has been created that integrates the necessary elements. The effects of the tests are presented in a separate document.</p>"},{"location":"minimal-os-for-fobnail/#fobnail-integration_5","title":"Fobnail integration","text":"<p>At this point, the Fobnail Attester application is strongly dependent on Linux. Mainly due to the fact that its development took place on this operating system. Therefore, it is important that the created minimal OS also has an integrated attester application. The main dependencies of its operation are drivers for USB, USB EEM and TPM, but running them under Linux will not cause major problems.</p>"},{"location":"minimal-os-for-fobnail/#license_5","title":"License","text":"<p>The Linux Kernel runs under GPL-2.0 License which can be checked in documentation.</p>"},{"location":"minimal-os-for-fobnail/#linux-with-busybox-userspace","title":"Linux with Busybox userspace","text":"<p>The main advantage of Busybox based userspace is its small size. Also booting time would be significantly faster than userspace with fully-featured init system. With Busybox, init system can be replaced by a simple shell script.</p>"},{"location":"minimal-os-for-fobnail/#running-in-dlme_6","title":"Running in DLME","text":"<p>Since we are still running Linux, there are no problems here.</p>"},{"location":"minimal-os-for-fobnail/#fobnail-integration_6","title":"Fobnail integration","text":"<p>Since busybox based userspace doesn't have big expectation of Linux feature set, kernel can be reduced. Busybox can be compiled with only those features we need. Currently, Fobnail Attester depends on another program to configure network interface created by Fobnail Token. This is <code>systemd-networkd</code>, but in Busybox userspace it would have to be something else. It should be noted that configuration should be done on hotplug event, simply using <code>ifconfig</code> may be unreliable because:</p> <ul> <li>It won't work if Fobnail Token isn't already plugged in.</li> <li>It won't work if Fobnail Token is plugged out and back in.</li> </ul> <p>Hotplug detection and interface setup could be implemented in Fobnail Attester through Netlink.</p>"},{"location":"minimal-os-for-fobnail/#linux-with-go-userspace","title":"Linux with Go userspace","text":"<p>u-root provides an easy way to deploy Go programs as standalone initramfs images. It is used by the LinuxBoot project for creating small Linux distro that acts as bootloader for other OSes (through kexec).</p>"},{"location":"minimal-os-for-fobnail/#running-in-dlme_7","title":"Running in DLME","text":"<p>Since we are still running Linux, there are no problems here.</p>"},{"location":"minimal-os-for-fobnail/#fobnail-integration_7","title":"Fobnail integration","text":"<p>Fobnail Attester is written in C, and it rather doesn't make sense to integrate it with Go userland. Also, it should be noted that <code>u-root</code> built initramfs contains only executable - all Go modules are linked into a single binary. Unless we want to rewrite Fobnail Attester there is no point in using userspace that was designed be Go-only. Rewriting Fobnail Attester in Go may give benefits of producing less vurnelable code.</p>"},{"location":"minimal-os-for-fobnail/#little-kernel-trusted-little-kernel","title":"Little Kernel / Trusted Little Kernel","text":"<p>Little Kernel is a small, embedded monolithic kernel that runs on x86, ARM and RISC-V among others, provides a custom very basic libc. LK focuses on ARM platforms and lacks drivers for devices typically found in x86 platforms. LK has been used as a base for aboot (Android bootloader) and Fuchsia OS.</p> <p>Trusted Little Kernel (available at <code>https://nv-tegra.nvidia.com/r/3rdparty/ote_partner/tlk.git</code>, not accessible through web browser - must be cloned with <code>git</code>) is a fork of LK intended to be run as TEE OS. It is developed by NVIDIA for Tegra platforms, support for all other platforms has been removed.</p>"},{"location":"minimal-os-for-fobnail/#running-in-dlme_8","title":"Running in DLME","text":"<p>LK boots over Multiboot 1 which is not supported by SKL. The problem is similar to that with Zephyr (see Zephyr section for detail). However Multiboot2 support could be added.</p>"},{"location":"minimal-os-for-fobnail/#fobnail-integration_8","title":"Fobnail integration","text":"<p>Running Fobnail Attester on LK would be problematic to say the last and the reasons for that are:</p> <ul> <li>LK lacks most drivers including USB host drivers (UHCI, OHCI, EHCI, XHCI),   USB EEM driver and TPM drivers.</li> <li>Lack of cryptographic library in LK. TLK does provide one (potentially could   be).</li> <li>Default C library is too much constrained - provides only most basic API like   string operations, printing, etc. lacks anything more complex, including   networking support, there is a LK's   fork of Newlib, however of unknown   quality.</li> <li>TCP/IP is provided by <code>minip</code> library (which is part of LK), attester depends   on <code>libcoap3</code> which either would have to be ported to <code>minip</code> or <code>minip</code> would   have to be integrated with <code>newlib</code>.</li> <li>LK has no suitable bootloader capabilities   lkboot could   serve as reference to develop custom bootloader.</li> </ul>"},{"location":"minimal-os-for-fobnail/#license_6","title":"License","text":"<p>Little Kernel uses MIT License.</p>"},{"location":"minimal-os-for-fobnail/#fuchsia-zircon","title":"Fuchsia (Zircon)","text":"<p>Fuchsia is a general-purpose OS developed by Google. Its purpose is to replace GNU/Linux in Google products (like Android, Chrome OS) with Zircon microkernel (used to be known as Magenta) and custom userland. Fuchsia runs on x86-64 and ARM64. There used to be an unofficial RISC-V port, however it has been unmaintained for years. Support for 32-bit architectures was dropped some time ago.</p> <p>Zircon is based on LK, however similarities between these two are small and constantly decreasing. LK is a kernel intended for embedded usage, while Zircon is a general-purpose microkernel that could compete with Linux.</p>"},{"location":"minimal-os-for-fobnail/#running-in-dlme_9","title":"Running in DLME","text":"<p>Historically Zircon used Multiboot 1 for booting. Now it uses ZBI with a UEFI bootloader called Gigaboot. Multiboot 1 support is still present, but SKL doesn't support it anyway. See Zephyr section above for details.</p>"},{"location":"minimal-os-for-fobnail/#fobnail-integration_9","title":"Fobnail integration","text":"<p>Fuchsia provides a Unix-like environment with musl C library. Network is available but there is no EEM driver, and only XHCI host driver is supported. Since EHCI is still widely used, this is a major limitation. TPM driver is available but without <code>libtss2</code>.</p> <p>Zircon has a kexec-like capability which allows to boot another Zircon instance. This is known as <code>mexec</code>.</p> <p>Following things would have to be done:</p> <ul> <li>Bring <code>libtss2</code> stack to Zircon.</li> <li>Bring EEM driver. There is ECM driver available, which could serve as   reference.</li> <li>Bring at least USB EHCI driver, ideally should support UHCI and OHCI too.</li> <li>Figure out how to use <code>mexec</code> to boot Linux.</li> </ul>"},{"location":"minimal-os-for-fobnail/#license_7","title":"License","text":"<p>Information can be checked here. Basically, we will be using here components under MIT, BSD and Apache 2.0 licenses.</p>"},{"location":"minimal-os-for-fobnail/#xen","title":"Xen","text":"<p>Xen is a bare-metal hypervisor available on x86 and ARM. It is able to run Linux in a paravirtualized environment. Xen contains only drivers absolutely necessary for hypervisor and VM to boot. Control over most of the hardware is handed to the first VM known as Dom0. Usuallly Linux runs in Dom0, there are other OSes which also support running in Dom0 (BSD, Solaris), however there is no advantage of using them over Linux. Xen also has ability to run in dom0-less mode - bootloader provides VM images and Xen starts VMs on their own (see section below for details).</p>"},{"location":"minimal-os-for-fobnail/#running-in-dlme_10","title":"Running in DLME","text":"<p>Xen is supported by Trenchboot's GRUB and can run without any modifications. See xen-in-dlme.md for demo.</p>"},{"location":"minimal-os-for-fobnail/#integration-with-fobnail","title":"Integration with Fobnail","text":"<p>Domain 0 less mode eliminates need for trusted VM. Also, since Xen itself is responsible for booting multiple VMs there is no need for tools that manage Xen (which don't work on any OS besides Linux). Fobnail Attester could be integrated in a similar way that with CAmkES based VM (see CAmkES section above for details). The main difference would be that the secure component would be a separate VM.</p> <p>So it look like we could use Xen while we talk about early launch but in late launch scenarios it makes no sense. And this is one of key reasons why Xen does not meet the minimal OS requirements, because implementing late launch scenarios is definitelly something that we would like to achive with the OS.</p>"},{"location":"minimal-os-for-fobnail/#license_8","title":"License","text":"<p>Xen Project is developed under GPL-2.0 License.</p>"},{"location":"minimal-os-for-fobnail/#summary","title":"Summary","text":"<ul> <li>The above report outlines 8 operating systems that should be considered   candidates for Fobnail Token interoperability.</li> <li>The basic choice is Linux, the operating system based on it is created with   the use of Yocto Project. All achievements   can be reproduced at any time using the   meta-fobnail layer.</li> <li>As part of the report, other systems were also checked. The possibility of   running them in DLME and the integration of the   Fobnail Attester application   was checked for each of them.</li> <li>The description of an attempt to run Zephyr on PC Engines apu2 in order to   verify the current state of the system to work with Fobnail Token has been   included. The effects are described in the PoC test section.</li> <li>The table below contains summary of features of all OSes together with theirs   scores. Please note that when comparing driver support we take into account   not only drivers which are part of the kernel, but also available userspace   drivers. Each score is computed using the following rules:</li> <li>if feature is present then +1,</li> <li>if feature is not present then 0, or if feature would be hard to implement     then -1,</li> <li>if this is a hard requirement then multiple result by 2.</li> </ul> <p>Definition of requirements can be found here.</p> OS USB host driver USB EEM driver Network stack TPM driver OS portability Bootloader capabilities C library Microkernel CPU Architecture support Bootable by SKL License Score Zephyr Yes (+2) Yes (+2) Yes (+2) PoC available (0) Limited (-1) No (0) Yes (+2) No (0) Good (+1) [^4] No (0) [^6] OK (0) 8 Xous No (0) No (0) Yes (+2) No (0) Limited (-1) No (0) No (0) Yes (+1) RISC-V only (-1) No (0) OK (0) 1 seL4 No (0) [^1] No (0) [^2] Yes (+2) No (0) Limited (-1) No (0) Yes (+2) Yes (+1) Good (+1) [^3] Yes (+2) OK (but problematic with Genode) (0) 7 Linux Yes (+2) Yes (+2) Yes (+2) Yes (+2) Yes (+1) Yes (kexec) (+2) Yes (+2) No (0) Good (+1) [^5] Yes (+2) OK (0) 16 LK No (0) No (0) Limited (-2) [^7] No (0) Yes (+1) No (0) Limited (-2) No (0) Good (+1) [^8] No (0) OK (0) -2 Fuchsia Limited (0) [^9] No (0) Yes (+2) Limited (0) [^10] Yes (+1) Yes (mexec) (+2) Yes (+2) Yes (+1) Good (+1) [^11] No (0) OK (0) 7 <p>[^1]: seL4 has an old unmaintained driver with no xHCI support. Better driver is       available only from Genode.</p> <p>[^2]: available from Genode only</p> <p>[^3]: supports x86, ARM and RISC-V</p> <p>[^4]: supports x86, ARM, RISC-V, SPARC and MIPS</p> <p>[^5]: supports most of the architectures, much more than any other OS listed       here</p> <p>[^6]: not bootable due to of lack Multiboot1 support in SKL</p> <p>[^7]: uses custom library, no integration with libc, which complicates using it       with <code>libcoap3</code></p> <p>[^8]: supports x86, ARM, RISC-V and MIPS</p> <p>[^9]: supports XHCI only</p> <p>[^10]: TPM driver is present but there is no <code>libtss2</code> support</p> <p>[^11]: supports 64-bit x86 and ARM. Support for 32-bit architectures has been        dropped a while ago and is not coming back</p>"},{"location":"minimal-os-for-fobnail/#kudos","title":"KUDOS","text":"<p>We want to thank the people listed below for their help in this research (listed alphabetically).</p> <ul> <li>Andrew Cooper (@andyhhp)</li> <li>Sid Hussmann (@sidhussmann)</li> <li>Marek Marczykowski-G\u00f3recki (@marmarek)</li> <li>Demi Marie Obenour (@DemiMarie)</li> <li>Daniel P. Smith (@dpsmith)</li> </ul>"},{"location":"networking_setup/","title":"Networking setup","text":"<p>Note: these steps are required only when firmware is run on PC. They shouldn't be done for hardware Fobnail Token.</p> <p>To run Fobnail firmware directly on your PC a special network interface to communicate with the external world is needed. You can create such an interface by executing the following commands:</p> <pre><code>sudo ip tuntap add fobnail0 mode tap user `whoami`\n</code></pre> <pre><code>sudo ip addr add 169.254.0.8/16 dev fobnail0\n</code></pre> <pre><code>sudo ip link set dev fobnail0 up\n</code></pre> <p>To make this persistent across reboots, you can use <code>systemd-networkd</code>, which ships with most distributions. To make the interface persistent, follow these steps:</p> <ul> <li>Create <code>/etc/systemd/network/fobnail0.netdev</code>.</li> </ul> <pre><code>[NetDev]\nName=fobnail0\nKind=tap\n\n[Tap]\nUser=put your user name here\n</code></pre> <ul> <li>Create <code>/etc/systemd/network/fobnail0.network</code>.</li> </ul> <pre><code>[Match]\nName=fobnail0\n\n[Network]\nAddress=169.254.0.8/16\nDHCPServer=false\n</code></pre> <ul> <li>Enable <code>systemd-networkd</code>.</li> </ul> <pre><code>sudo systemctl enable --now systemd-networkd\n</code></pre> <p>You should see a new network interface created.</p> <pre><code>ip addr show dev fobnail0\n</code></pre> <pre><code>40: fobnail0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc fq_codel state DOWN group default qlen 1000\n    link/ether 8e:36:f4:4c:98:28 brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::8c36:f4ff:fe4c:9828/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> <p>You should see the same interface inside Docker container.</p> <pre><code>run-fobnail-sdk.sh /bin/bash\n</code></pre> <p>Inside docker container:</p> <pre><code>ip link show fobnail0\n</code></pre> <pre><code>40: fobnail0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000\n    link/ether 8e:36:f4:4c:98:28 brd ff:ff:ff:ff:ff:ff\n</code></pre> <p>Note: TAP interface passthrough may not work if your distro is using SELinux. If you can't see the network interface in Docker, try turning SELinux into permissive mode. <pre><code>$ sudo setenforce 0\n</code></pre></p> <p>If you are using WSL (Windows Subsystem for Linux) with Docker Desktop, interface passthrough won't work because Docker is located on a separate Virtual Machine. In that case, you can still use Fobnail SDK to build the firmware, but the firmware must be run from outside the container.</p>"},{"location":"token_provisioning/","title":"Fobnail Token provisioning","text":"<p>The process of Token provisioning is initialized by Platform Owner application.</p>"},{"location":"token_provisioning/#prerequisites","title":"Prerequisites","text":"<p>Platform Owner binary expects two files: PO certificate chain <code>cert_chain.pem</code> and private key <code>po_priv_key.pem</code>, in that order. For quick start both of those files can be produced using these TL;DR instructions.</p> <p>Certificate chain must begin with the root CA that was passed as <code>FOBNAIL_PO_ROOT</code> when Token firmware was built.</p>"},{"location":"token_provisioning/#provisioning-instructions","title":"Provisioning instructions","text":"<p>Instructions below assume that <code>fobnail-platform-owner</code> was installed to a directory in <code>$PATH</code> variable and both required PEM files are in current directory. The process differs slightly between physical Token and emulated one, choose proper version before continuing.</p> Physical Fobnail TokenPC simulation <ol> <li> <p>Plug in the Token. It will present itself as network interface, check its    name in <code>dmesg</code> - search for lines like these one, where <code>enp0s26u1u1</code> is    the name of the interface:</p> <pre><code>[54.928687] cdc_eem 1-1.1:1.0 usb0: register 'cdc_eem' at usb-0000:00:1a.0-1.1, CDC EEM Device, f6:82:61:5e:71:2a\n[55.052471] cdc_eem 1-1.1:1.0 enp0s26u1u1: renamed from usb0\n[55.153313] cdc_eem 1-1.1:1.0 enp0s26u1u1: unregister 'cdc_eem' usb-0000:00:1a.0-1.1, CDC EEM Device\n</code></pre> <p>Red LED should be lit on the Token to signal that it isn't provisioned yet.</p> </li> <li> <p>Assign IP to that interface. There is no need to make it permanent,    provisioning is a one-time operation. Change <code>enp0s26u1u1</code> to the name of    your interface:</p> <pre><code>sudo nmcli con add save no con-name Fobnail ifname enp0s26u1u1 \\\n     type ethernet ip4 169.254.0.8/16 ipv6.method disabled\n</code></pre> </li> <li> <p>Run Platform Owner application:</p> <pre><code>fobnail-platform-owner cert_chain.pem po_priv_key.pem\n</code></pre> <p>After a while, green LED will blink once to report that the Token provisioning was successful. After that Token enters idle state in which both LEDs blink shortly every 5 seconds.</p> </li> </ol> <ol> <li> <p>Network should be set up as a part of build instructions. If that isn't    the case, follow instructions.</p> </li> <li> <p>Start firmware by executing the following commands (from <code>fobnail</code>    directory). Make sure that <code>FOBNAIL_PO_ROOT</code> and <code>FOBNAIL_EK_ROOT_DIR</code>    are the same as during initial build, otherwise firmware will be rebuilt.    If TPM is also emulated, <code>FOBNAIL_EXTRA_EK_ROOT</code> in addition or instead    of <code>FOBNAIL_EK_ROOT_DIR</code> should be provided.</p> <pre><code>env FOBNAIL_LOG=info FOBNAIL_PO_ROOT=root_ca.crt \\\n    FOBNAIL_EK_ROOT_DIR=tpm_ek_roots ./build.sh -t pc --run\n</code></pre> <p>Contrary to physical Token, simulation doesn't have physical LEDs, so the state is reported in textual form:</p> <pre><code>INFO  pal_pc::led &gt; LED controller state: TokenNotProvisioned\n</code></pre> </li> <li> <p>Run Platform Owner application:</p> <pre><code>fobnail-platform-owner cert_chain.pem po_priv_key.pem\n</code></pre> <p>This will start the provisioning, with progress and result printed in the console:</p> <pre><code>INFO  fobnail     &gt; new client: 169.254.0.8:40625\nINFO  fobnail::server::token_provisioning &gt; Commencing token provisioning\nINFO  fobnail::server::token_provisioning &gt; Certificate chain loaded\nINFO  fobnail::server::token_provisioning &gt; Generating new Ed25519 keypair\nINFO  fobnail::server::token_provisioning &gt; Token provisioning complete\nINFO  pal_pc::led                         &gt; LED controller state: TokenProvisioningComplete\nINFO  pal_pc::led                         &gt; LED controller state: TokenWaiting\nINFO  fobnail                             &gt; disconnect client: 169.254.0.8:40625\n</code></pre> </li> </ol>"},{"location":"token_provisioning/#unprovisioning","title":"Unprovisioning","text":"<p>In some cases (PO certificate update, change of owner or when moving from test provisioning to target one) it is necessary to perform provisioning again. To do so, previously installed by PO certificate must be removed. Instructions are different for physical and simulated Token, but in both cases all secrets protected by Token are removed for security reasons. If those are important to you, make sure you have a copy or are able to recreate them.</p> Physical Fobnail TokenPC simulation <p>To unprovision physical Token you have to flash it again using these instructions. Pass new <code>FOBNAIL_PO_ROOT</code> if needed.</p> <p>Unprovisioning in case of PC simulation is done by removing virtual flash contents by removing <code>target/flash.bin</code> file. After that, start the simulation as usual, flash file will be recreated with no PO certificate provisioned.</p> <p>Now you can repeat provisioning instructions.</p>"},{"location":"token_provisioning/#summary-and-next-steps","title":"Summary and next steps","text":"<p>In this state Fobnail Token is provisioned and awaits platform provisioning. Further instructions can be found in example applications, like disk encryption.</p>"},{"location":"tpm-simulators/","title":"TPM simulators","text":"<p>It is possible to use TPM simulators instead of real TPMs for testing purposes only. Two simulators were tested and are known to be working with Fobnail: Microsoft's and IBM's.</p>"},{"location":"tpm-simulators/#differences-between-simulated-and-real-tpm","title":"Differences between simulated and real TPM","text":"<p>The main difference is that simulator is started after system is up. This means that there will be no measurements of firmware nor OS. Attestation is based on these measurements, without them there is nothing to attest to, which makes use of simulated TPM useless for practical applications. It also means that nothing called <code>TPM2_Startup</code> command. Attester is able to detect this and calls that function automatically.</p> <p>Hardware and firmware TPM vendors give assurance of proper functioning of their TPMs. This is done by creating a certificate for each TPM separately, specifically for their Endorsement Keys (EKs). These certificates are created during TPM manufacturing and provisioning process, and are written to NVRAM. They point to their signing certificates through <code>authorityInfoAccess</code> X509V3 extension. The chain continues until a self-signed root that is implicitly trusted. That root must be known by Fobnail Token in advance in order to trust given TPM.</p> <p>For simulated TPM, such certificate has to be manually created and injected into NVRAM. EK certificate is created for EK created from EPS (Endorsement Primary Seed), which is randomly created when the simulator is started for the first time. Nobody is issuing certificates for all instances of simulated TPMs. One of the reasons is probably the fact that emulators are not fully compatible with specification, especially when it comes to hardware protection mechanisms (Physical Presence, protected storage etc.).</p> <p>There are also other small differences, e.g. after non-orderly shutdown <code>safe</code> field in <code>TPMS_CLOCK_INFO</code> structure is set after 12 seconds in simulator, while specification allows for up to 2^22 milliseconds (around 70 minutes) to help with NVRAM wear leveling. Note that this field is checked by Fobnail during attestation.</p>"},{"location":"tpm-simulators/#building","title":"Building","text":"ms-tpm-20-refibmswtpm2 <p>Clone the repository and checkout commit that is known to work (unfortunately, this repository doesn't use tags):</p> <pre><code>git clone https://github.com/microsoft/ms-tpm-20-ref.git\ncd ms-tpm-20-ref/TPMCmd/\ngit checkout f74c0d9686625c02b0fdd5b2bbe792a22aa96cb6\n</code></pre> <p>Install prerequisites:</p> <pre><code>sudo apt install autoconf-archive pkg-config build-essential automake \\\n     tss2 libssl-dev\n</code></pre> <p>Compile:</p> <pre><code>./bootstrap\n./configure\nmake\n</code></pre> <p>TPM simulator is started with:</p> <pre><code>./Simulator/src/tpm2-simulator\n</code></pre> <p>Clone the repository and checkout tag that is known to work:</p> <pre><code>git clone https://git.code.sf.net/p/ibmswtpm2/tpm2 ibmswtpm2-tpm2\ncd ibmswtpm2-tpm2/src/\ngit checkout rev1563\n</code></pre> <p>Install prerequisites:</p> <pre><code>sudo apt install build-essential libssl-dev tss2\n</code></pre> <p>Compile:</p> <pre><code>make\n</code></pre> <p>TPM simulator is started with:</p> <pre><code>./tpm_server\n</code></pre> <p>The last command will create <code>NVChip</code> file in the current directory. Removing it (while simulator is not running) will restore TPM to clean state.</p>"},{"location":"tpm-simulators/#provisioning-simulated-tpm","title":"Provisioning simulated TPM","text":"<p>As mentioned, EK certificate must be written to TPM NVRAM. In addition, it must point to valid CA certificate that will be downloaded during platform provisioning. A script for simplifying this process and required configuration are included in Attester's repository. <code>tpm2-tools</code> and <code>openssl</code> are used by this script, so they must be installed.</p> <p>To create root certificate, EK certificate and write the latter to NVRAM, it is enough to call the following (<code>-s</code> tells to send <code>TPM2_Startup</code> command):</p> <pre><code>$ ./tools/tpm_manufacture.sh -s\nSending TPM2_Startup command\nGenerating a RSA private key\n................................................+++++\n................+++++\nwriting new private key to '/home/user/fobnail-attester/tools/keys_and_certs/ca_priv.pem'\n-----\nSignature ok\nsubject=C = PL, O = Fobnail, ST = State, CN = EK certificate\nGetting CA Private Key\n\n\nDone.\nTo test:\n        tpm2_nvread -C o 0x01C00002 | openssl x509 -text -noout -inform DER\n</code></pre> <p>Check if certificate was written properly by executing suggested command:</p> <pre><code>$ tpm2_nvread -C o 0x01C00002 | openssl x509 -text -noout -inform DER\nWARN: Reading full size of the NV index\nCertificate:\n    Data:\n        Version: 3 (0x2)\n        Serial Number:\n            66:e5:d8:5a:1f:4b:38:95:67:9c:2a:b7:b1:2d:e5:55:e9:b2:ee:2e\n        Signature Algorithm: sha256WithRSAEncryption\n        Issuer: C = PL, O = Fobnail, ST = State, CN = CA certificate\n        Validity\n            Not Before: Jan  4 19:14:00 2023 GMT\n            Not After : Feb  3 19:14:00 2023 GMT\n        Subject: C = PL, O = Fobnail, ST = State, CN = EK certificate\n        Subject Public Key Info:\n            Public Key Algorithm: rsaEncryption\n                RSA Public-Key: (2048 bit)\n                Modulus:\n                    00:b1:a0:41:73:ca:33:e4:be:78:bf:21:e1:19:43:\n                    22:1c:50:90:44:23:bd:a1:0b:d6:1c:9e:c7:bd:07:\n                    c0:ba:1e:be:f3:b1:c7:32:9d:8a:99:64:6c:4b:6e:\n                    7f:fe:9a:2a:58:50:34:cd:4b:a1:38:c4:f3:a2:25:\n                    01:87:00:9d:75:5a:b6:8d:46:a6:c9:b6:8c:62:5c:\n                    8d:95:1a:06:d9:38:79:d5:41:80:ce:e1:4e:23:f0:\n                    fe:b3:43:58:05:13:38:7b:cb:c5:8c:b6:ea:6b:b1:\n                    75:10:79:7b:f0:1e:99:01:94:43:5d:4b:85:22:a5:\n                    66:cd:9c:c4:36:49:97:df:03:26:9c:2c:28:5a:1c:\n                    6b:fc:59:3d:e8:94:e7:dc:21:74:25:9a:32:d1:21:\n                    2b:98:8d:e4:c3:84:39:cc:eb:c6:1b:b6:05:97:c2:\n                    61:22:ed:f4:3a:3c:31:e5:e2:c8:b6:41:f9:33:6d:\n                    de:9e:3d:bf:bf:11:d8:e6:65:d8:7e:24:d1:11:00:\n                    54:a6:71:f8:8e:04:a8:81:a7:51:22:07:2f:67:ee:\n                    b7:11:8f:d9:f6:c9:07:b8:61:9b:ee:45:c6:2e:ad:\n                    b0:26:5e:88:52:3b:5c:3d:82:36:45:26:00:35:c0:\n                    4c:4a:3d:c9:6a:4a:4a:ed:32:65:51:e5:b4:a4:1c:\n                    65:eb\n                Exponent: 65537 (0x10001)\n        X509v3 extensions:\n            X509v3 Authority Key Identifier:\n                keyid:7C:12:EB:3F:07:E3:82:43:57:7C:0D:17:84:40:E3:70:CE:39:C2:E4\n\n            Authority Information Access:\n                CA Issuers - URI:http://127.0.0.1:8080/ca_cert.der\n\n            X509v3 Basic Constraints:\n                CA:FALSE\n            X509v3 Key Usage:\n                Key Encipherment\n    Signature Algorithm: sha256WithRSAEncryption\n         5e:b2:f9:76:a6:fe:25:31:ec:b5:c9:27:7b:96:9b:48:00:e2:\n         17:da:cf:6e:2a:40:f4:8f:76:2c:d8:75:eb:42:45:43:ef:c0:\n         db:56:53:1b:f8:57:4e:3d:56:3c:6b:83:8a:55:a8:53:cd:4c:\n         c6:71:ed:8f:d0:80:6d:6d:5b:08:6f:07:60:7d:6c:c6:7e:37:\n         00:6b:00:41:22:6b:2f:06:10:07:f0:3a:d4:f4:26:ca:32:a4:\n         9a:30:f0:d5:0f:48:a4:dd:fd:59:8c:35:b2:5c:62:9f:71:db:\n         4e:f0:37:68:10:38:c3:eb:96:f2:85:fa:32:ba:e2:9b:a5:94:\n         df:9d:bd:df:69:ff:d8:98:40:2d:0c:30:d4:b4:76:db:fb:e6:\n         a8:04:9d:81:83:66:24:83:8f:eb:4d:c4:9e:7f:da:18:22:1a:\n         99:4e:15:f1:cf:56:05:37:c7:be:98:44:be:d6:d5:ae:e2:f6:\n         7e:40:a7:07:c9:c0:b1:da:c6:b4:7b:bf:0b:41:89:5e:d4:76:\n         98:51:81:1e:4f:dd:6c:f5:aa:5b:32:ed:ea:de:8b:cd:ca:f1:\n         36:0a:41:0a:46:ff:44:d7:8a:fe:fe:c4:0f:d2:7c:53:76:ad:\n         0f:df:1b:65:51:ed:05:7b:be:bf:8a:4e:68:65:4f:6d:3f:14:\n         27:d3:2c:f3\n</code></pre> <p>There may be more lines with warnings and even errors printed before that. They come from TCTI (TPM Command Transmission Interface) and are caused by failed attempts to use another interface (e.g. physical TPM) before driver for simulator is tried. They can be safely ignored, as long as content of certificate is printed afterwards.</p> <p>Certificate in <code>tools/keys_and_certs/ca_cert.der</code> is the one that has to be passed to <code>build.sh</code> in <code>FOBNAIL_EXTRA_EK_ROOT</code> variable, see building instructions for details.</p> <p>Configuration assumes that CA certificate will be made available at address <code>http://127.0.0.1:8080/ca_cert.der</code>, to change this please edit <code>ek_v3.ext</code> in <code>tools</code> directory.</p> <p>If you have to re-run the manufacturing process (e.g. EK root certificate is lost or some changes were done to its extensions) start <code>tpm_manufacture.sh</code> with additional <code>-f</code> flag that will overwrite EK certificate even if it is already present. Do not use it on real TPM, there is no way of recovering original certificate if it was removed!.</p> <p>Another option is to remove <code>NVChip</code> file. This option should be used if the platform provisioning is to be repeated, as it also removes saved EK (not only EK certificate) and AIK. In that case, <code>-f</code> is not required.</p>"},{"location":"tpm-simulators/#using-simulated-tpm","title":"Using simulated TPM","text":"<p>For most cases running TPM simulator is enough. Only platform provisioning needs HTTP server in addition to TPM simulator. Easiest way to do so is to use Python:</p> <pre><code>cd tools/keys_and_certs\npython -m http.server 8080\n</code></pre> <p>HTTP server can be closed after platform is successfully provisioned and never started again, unless another provisioning is required.</p>"},{"location":"xen-in-dlme/","title":"Running Xen in DLME","text":"<p>During test we are using meta-fobnail which is our custom Yocto layer. meta-fobnail has been described more in-depth in meta-fobnail in DLME. Here we are using Yocto as a base OS because it already provides TrenchBoot's GRUB and Landing Zone which are required to boot Xen and Linux itself to test whether Xen is working.</p> <p>Build Yocto image and flash it to SDcard.</p> <pre><code>$ mkdir yocto\n$ cd yocto\n$ git clone https://github.com/fobnail/meta-fobnail\n$ kas-container build meta-fobnail/kas-debug.yml\n</code></pre> <p>Build latest Xen version</p> <pre><code>$ git clone https://xenbits.xen.org/git-http/xen.git\n$ cd xen\n$ git co RELEASE-4.16.1\n$ ./configure\n$ make -j$(nproc)\n</code></pre> <p>Copy <code>xen/xen</code> file to Yocto boot partition and add following entry to <code>/boot/grub/grub.cfg</code>.</p> <pre><code>menuentry 'XEN' {\n  slaunch skinit\n  slaunch_module (hd0,msdos1)/lz_header.bin\n  multiboot2 /xen loglvl=all guest_loglvl=all com1=115200,8n1 console=com1\n  module2 /bzImage root=/dev/mmcblk0p2 console=ttyS0,115200 earlyprintk=serial,ttyS0,115200 rootwait\n}\n</code></pre> <p>When booting platform, Landing Zone starts first, then Xen, and then Linux.</p> <pre><code>shasum calculated:\n0x001001dc: d0 8d a8 6f 97 cc 6b 6b 99 9b 1c e1 e7 0b 60 3c   ...o..kk......`&lt;\n0x001001ec: db a3 2d ac cc cc cc cc cc cc cc cc cc cc cc cc   ..-.............\nshasum calculated:\n0x001001f0: 56 2b de 09 b5 8b 8a 9b d5 40 1c 73 52 0e 37 74   V+.......@.sR.7t\n0x00100200: 58 3e 44 0c 9b a1 9e aa 35 a5 b5 be ba e3 b3 d2   X&gt;D.....5.......\nPCR extended\nshasum calculated:\n0x001001dc: 0c d1 e3 3c e3 f1 21 44 13 87 3d 88 b7 1e c5 6b   ...&lt;..!D..=....k\n0x001001ec: 35 fc 40 b0 56 2b de 09 b5 8b 8a 9b d5 40 1c 73   5.@.V+.......@.s\nshasum calculated:\n0x001001f0: 45 5b 59 f4 f8 8d 08 95 a6 c9 dc 3e 2c 28 c3 c7   E[Y........&gt;,(..\n0x00100200: 76 dc 0a 4f 55 89 54 a5 a9 bb 71 bf 02 97 da 8b   v..OU.T...q.....\nPCR extended\nkernel_size 0x00278bd0:\nshasum calculated:\n0x001001dc: 8f d0 9f b3 cf 33 c1 e0 e0 47 8c cf d0 8b 2c c9   .....3...G....,.\n0x001001ec: b8 b6 1a a4 45 5b 59 f4 f8 8d 08 95 a6 c9 dc 3e   ....E[Y........&gt;\nshasum calculated:\n0x001001f0: bc f4 aa 0d 2e 10 72 12 9d 42 ef bf 57 25 ad 56   ......r..B..W%.V\n0x00100200: de 40 86 45 16 11 75 3d 7e 3d 7e 4e 78 ba ae 61   .@.E..u=~=~Nx..a\nPCR extended\nModule 'root=/dev/mmcblk0p2 console=ttyS0,115200 earlyprintk=serial,ttyS0,115200' [0x00111000: 0x00939e80: ]\nshasum calculated:\n0x001001dc: fb 15 05 fd bc b7 09 e3 62 11 8e 13 06 7e c0 0b   ........b....~..\n0x001001ec: 53 45 4b d1 bc f4 aa 0d 2e 10 72 12 9d 42 ef bf   SEK.......r..B..\nshasum calculated:\n0x001001f0: 78 57 2d b4 2d 41 95 0a f8 2e 8c f1 5d 1c f5 55   xW-.-A......]..U\n0x00100200: 7c 6b 03 ac 90 c6 27 25 10 d0 23 1d 79 8d 25 17   |k....'%..#.y.%.\nPCR extended\npm_kernel_entry:\n0xcf800000: e9 5a 11 1c 00 0f 1f 00 02 b0 ad 1b 03 00 00 00   .Z..............\n0xcf800010: fb 4f 52 e4 c2 c2 c2 c2 d6 50 52 e8 00 00 00 00   .OR......PR.....\n0xcf800020: 88 00 00 00 a2 ae ad 17 01 00 00 00 10 00 00 00   ................\n0xcf800030: 04 00 00 00 06 00 00 00 06 00 00 00 08 00 00 00   ................\n0xcf800040: 0a 00 01 00 18 00 00 00 00 00 20 00 ff ff ff ff   .......... .....\n0xcf800050: 00 00 20 00 02 00 00 00 04 00 01 00 0c 00 00 00   .. .............\n0xcf800060: 02 00 00 00 c2 c2 c2 c2 05 00 01 00 14 00 00 00   ................\n0xcf800070: 00 00 00 00 00 00 00 00 00 00 00 00 c2 c2 c2 c2   ................\n0xcf800080: 07 00 01 00 08 00 00 00 09 00 01 00 0c 00 00 00   ................\n0xcf800090: 5e 10 3c 00 c2 c2 c2 c2 00 00 00 00 08 00 00 00   ^.&lt;.............\n0xcf8000a0: 0f 01 15 19 fe 1b 00 b9 00 00 00 00 8e d9 8e c1   ................\n0xcf8000b0: 8e e1 8e e9 8e d1 48 c7 c1 a0 00 00 00 0f 22 e1   ......H.......\".\n0xcf8000c0: 48 8b 25 3d 6f 27 00 6a 00 9d 68 08 e0 00 00 48   H.%=o'.j..h....H\n0xcf8000d0: 8d 05 03 00 00 00 50 48 cb 85 db 74 4c e8 9e c2   ......PH...tL...\n0xcf8000e0: 12 00 85 c0 74 3c b9 a2 06 00 00 31 d2 0f 30 b9   ....t&lt;.....1..0.\n0xcf8000f0: a0 00 80 00 0f 22 e1 a8 01 74 27 48 89 e2 48 81   .....\"...t'H..H.\nzero_page:\n0x00110018: 20 03 00 00 00 00 00 00 15 00 00 00 0c 00 00 00    ...............\n0x00110028: 00 00 80 cf d0 1f d7 cf 01 00 00 00 41 00 00 00   ............A...\n0x00110038: 6c 6f 67 6c 76 6c 3d 61 6c 6c 20 67 75 65 73 74   loglvl=all guest\n0x00110048: 5f 6c 6f 67 6c 76 6c 3d 61 6c 6c 20 63 6f 6d 31   _loglvl=all com1\n0x00110058: 3d 31 31 35 32 30 30 2c 38 6e 31 20 63 6f 6e 73   =115200,8n1 cons\n0x00110068: 6f 6c 65 3d 63 6f 6d 31 00 67 72 75 62 5f 72 65   ole=com1.grub_re\n0x00110078: 02 00 00 00 16 00 00 00 47 52 55 42 20 32 2e 30   ........GRUB 2.0\n0x00110088: 34 7e 72 63 31 00 6f 63 0a 00 00 00 1c 00 00 00   4~rc1.oc........\n0x00110098: 02 01 00 f0 37 d7 00 00 00 f0 00 f0 03 00 f0 ff   ....7...........\n0x001100a8: f0 ff f0 ff 73 69 00 67 03 00 00 00 59 00 00 00   ....si.g....Y...\n0x001100b8: 00 10 11 00 80 9e 93 00 72 6f 6f 74 3d 2f 64 65   ........root=/de\n0x001100c8: 76 2f 6d 6d 63 62 6c 6b 30 70 32 20 63 6f 6e 73   v/mmcblk0p2 cons\n0x001100d8: 6f 6c 65 3d 74 74 79 53 30 2c 31 31 35 32 30 30   ole=ttyS0,115200\n0x001100e8: 20 65 61 72 6c 79 70 72 69 6e 74 6b 3d 73 65 72    earlyprintk=ser\n0x001100f8: 69 61 6c 2c 74 74 79 53 30 2c 31 31 35 32 30 30   ial,ttyS0,115200\n0x00110108: 00 5f 65 6e 64 00 67 72 06 00 00 00 e8 00 00 00   ._end.gr........\n0x00110118: 18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n0x00110128: 00 fc 09 00 00 00 00 00 01 00 00 00 00 00 00 00   ................\n0x00110138: 00 fc 09 00 00 00 00 00 00 04 00 00 00 00 00 00   ................\n0x00110148: 02 00 00 00 00 00 00 00 00 00 0f 00 00 00 00 00   ................\n0x00110158: 00 00 01 00 00 00 00 00 02 00 00 00 00 00 00 00   ................\n0x00110168: 00 00 10 00 00 00 00 00 00 20 d8 cf 00 00 00 00   ......... ......\n0x00110178: 01 00 00 00 00 00 00 00 00 20 e8 cf 00 00 00 00   ......... ......\n0x00110188: 00 e0 17 00 00 00 00 00 02 00 00 00 00 00 00 00   ................\n0x00110198: 00 00 00 f8 00 00 00 00 00 00 00 04 00 00 00 00   ................\n0x001101a8: 02 00 00 00 00 00 00 00 00 00 d4 fe 00 00 00 00   ................\n0x001101b8: 00 50 00 00 00 00 00 00 02 00 00 00 00 00 00 00   .P..............\n0x001101c8: 00 00 00 00 01 00 00 00 00 00 00 2f 00 00 00 00   .........../....\n0x001101d8: 01 00 00 00 00 00 00 00 00 00 00 2f 01 00 00 00   .........../....\n0x001101e8: 00 00 00 01 00 00 00 00 02 00 00 00 00 00 00 00   ................\n0x001101f8: 09 00 00 00 b4 00 00 00 04 00 00 00 28 00 00 00   ............(...\n0x00110208: 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n0x00110218: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n0x00110228: 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00   ................\n0x00110238: 01 00 00 00 07 00 00 00 00 00 20 00 80 00 00 00   .......... .....\n0x00110248: d0 8b 27 00 00 00 00 00 00 00 00 00 40 00 00 00   ..'.........@...\n0x00110258: 00 00 00 00 07 00 00 00 03 00 00 00 00 00 00 00   ................\n0x00110268: 00 00 11 00 f0 8c 27 00 18 00 00 00 00 00 00 00   ......'.........\n0x00110278: 00 00 00 00 01 00 00 00 00 00 00 00 11 00 00 00   ................\n0x00110288: 07 00 00 00 00 00 00 00 80 0d 1c 00 00 0e 1c 00   ................\nlz_base:\n0x00100000: 90 02 58 80 00 80 ef be ad de cc cc cc cc cc cc   ..X.............\n0x00100010: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc   ................\n0x00100020: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc   ................\n0x00100030: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc   ................\n0x00100040: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc   ................\n0x00100050: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc   ................\n0x00100060: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc   ................\n0x00100070: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc   ................\n0x00100080: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc   ................\n0x00100090: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc   ................\n0x001000a0: f2 78 71 c6 77 66 b0 f2 d1 76 81 41 da 26 10 00   .xq.wf...v.A.&amp;..\n0x001000b0: 78 1d 7b a3 e5 53 97 52 cb 4e 13 61 ba 30 10 00   x.{..S.R.N.a.0..\n0x001000c0: 00 00 00 00 38 00 00 00 ac 3b 10 00 0d 33 10 00   ....8....;...3..\n0x001000d0: 40 00 00 00 80 36 10 00 e0 00 10 00 40 00 00 00   @....6......@...\n0x001000e0: 65 ce fe de 0d 48 a1 2c e0 3b 10 00 e0 3b 10 00   e....H.,.;...;..\n0x001000f0: 6e 01 10 00 21 3c 10 00 21 3c 10 00 5e 2a 10 00   n...!&lt;..!&lt;..^*..\nbootloader_data:\n0x00108058: 0f 04 5a 00 21 24 0b 00 da e5 42 df ec 6e 2e 3b   ..Z.!$....B..n.;\n0x00108068: fa 74 4f 97 ba 7d c5 d6 03 18 1d cd 8b 68 e1 a5   .tO..}.......h..\n0x00108078: 5c e0 37 e7 d7 e7 02 ee 21 18 04 00 f3 18 60 07   \\.7.....!.....`.\n0x00108088: 4e 6a 9f 9e 6a 76 c4 a7 d9 49 12 da 20 4a 32 73   Nj..jv...I.. J2s\n0x00108098: 11 0e 18 00 11 00 00 00 80 cf 00 00 00 00 20 0a   .............. .\n0x001080a8: 00 40 e8 cf 00 10 00 00 00 02 80 01 40 00 80 01   .@..........@...\nTPM event log:\n0xcfe84000: 00 00 00 00 03 00 00 00 00 00 00 00 00 00 00 00   ................\n0xcfe84010: 00 00 00 00 00 00 00 00 00 00 00 00 39 00 00 00   ............9...\n0xcfe84020: 53 70 65 63 20 49 44 20 45 76 65 6e 74 30 33 00   Spec ID Event03.\n0xcfe84030: 00 00 00 00 00 02 00 02 02 00 00 00 04 00 14 00   ................\n0xcfe84040: 0b 00 20 00 14 00 40 e8 cf 00 00 00 00 00 10 00   .. ...@.........\n0xcfe84050: 00 00 00 00 00 63 02 00 00 11 00 00 00 02 05 00   .....c..........\n0xcfe84060: 00 02 00 00 00 04 00 f3 18 60 07 4e 6a 9f 9e 6a   .........`.Nj..j\n0xcfe84070: 76 c4 a7 d9 49 12 da 20 4a 32 73 0b 00 da e5 42   v...I.. J2s....B\n0xcfe84080: df ec 6e 2e 3b fa 74 4f 97 ba 7d c5 d6 03 18 1d   ..n.;.tO..}.....\n0xcfe84090: cd 8b 68 e1 a5 5c e0 37 e7 d7 e7 02 ee 06 00 00   ..h..\\.7........\n0xcfe840a0: 00 53 4b 49 4e 49 54 12 00 00 00 02 05 00 00 02   .SKINIT.........\n0xcfe840b0: 00 00 00 04 00 d0 8d a8 6f 97 cc 6b 6b 99 9b 1c   ........o..kk...\n0xcfe840c0: e1 e7 0b 60 3c db a3 2d ac 0b 00 56 2b de 09 b5   ...`&lt;..-...V+...\n0xcfe840d0: 8b 8a 9b d5 40 1c 73 52 0e 37 74 58 3e 44 0c 9b   ....@.sR.7tX&gt;D..\n0xcfe840e0: a1 9e aa 35 a5 b5 be ba e3 b3 d2 23 00 00 00 4d   ...5.......#...M\n0xcfe840f0: 65 61 73 75 72 65 64 20 62 6f 6f 74 6c 6f 61 64   easured bootload\n0xcfe84100: 65 72 20 64 61 74 61 20 69 6e 74 6f 20 50 43 52   er data into PCR\n0xcfe84110: 31 38 12 00 00 00 02 05 00 00 02 00 00 00 04 00   18..............\n0xcfe84120: 0c d1 e3 3c e3 f1 21 44 13 87 3d 88 b7 1e c5 6b   ...&lt;..!D..=....k\n0xcfe84130: 35 fc 40 b0 0b 00 45 5b 59 f4 f8 8d 08 95 a6 c9   5.@...E[Y.......\n0xcfe84140: dc 3e 2c 28 c3 c7 76 dc 0a 4f 55 89 54 a5 a9 bb   .&gt;,(..v..OU.T...\n0xcfe84150: 71 bf 02 97 da 8b 17 00 00 00 4d 65 61 73 75 72   q.........Measur\n0xcfe84160: 65 64 20 4d 42 49 20 69 6e 74 6f 20 50 43 52 31   ed MBI into PCR1\n0xcfe84170: 38 11 00 00 00 02 05 00 00 02 00 00 00 04 00 8f   8...............\n0xcfe84180: d0 9f b3 cf 33 c1 e0 e0 47 8c cf d0 8b 2c c9 b8   ....3...G....,..\n0xcfe84190: b6 1a a4 0b 00 bc f4 aa 0d 2e 10 72 12 9d 42 ef   ...........r..B.\n0xcfe841a0: bf 57 25 ad 56 de 40 86 45 16 11 75 3d 7e 3d 7e   .W%.V.@.E..u=~=~\n0xcfe841b0: 4e 78 ba ae 61 1a 00 00 00 4d 65 61 73 75 72 65   Nx..a....Measure\n0xcfe841c0: 64 20 4b 65 72 6e 65 6c 20 69 6e 74 6f 20 50 43   d Kernel into PC\n0xcfe841d0: 52 31 37 11 00 00 00 02 05 00 00 02 00 00 00 04   R17.............\n0xcfe841e0: 00 fb 15 05 fd bc b7 09 e3 62 11 8e 13 06 7e c0   .........b....~.\n0xcfe841f0: 0b 53 45 4b d1 0b 00 78 57 2d b4 2d 41 95 0a f8   .SEK...xW-.-A...\n0xcfe84200: 2e 8c f1 5d 1c f5 55 7c 6b 03 ac 90 c6 27 25 10   ...]..U|k....'%.\n0xcfe84210: d0 23 1d 79 8d 25 17 48 00 00 00 72 6f 6f 74 3d   .#.y.%.H...root=\n0xcfe84220: 2f 64 65 76 2f 6d 6d 63 62 6c 6b 30 70 32 20 63   /dev/mmcblk0p2 c\n0xcfe84230: 6f 6e 73 6f 6c 65 3d 74 74 79 53 30 2c 31 31 35   onsole=ttyS0,115\n0xcfe84240: 32 30 30 20 65 61 72 6c 79 70 72 69 6e 74 6b 3d   200 earlyprintk=\n0xcfe84250: 73 65 72 69 61 6c 2c 74 74 79 53 30 2c 31 31 35   serial,ttyS0,115\n0xcfe84260: 32 30 30 00 00 00 00 00 00 00 00 00 00 00 00 00   200.............\n0xcfe84270: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n...\nlz_main() is about to exit\n Xen 4.16.1\n(XEN) Xen version 4.16.1 (akowalski@) (gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0) debug=n Fri May  6 12:41:07 CEST 2022\n(XEN) Latest ChangeSet: Tue Apr 12 14:21:23 2022 +0200 git:f265444922\n(XEN) build-id: a5224ddd598819a4ba78754a6e0bd7c15f9983e1\n(XEN) Bootloader: GRUB 2.04~rc1\n(XEN) Command line: loglvl=all guest_loglvl=all com1=115200,8n1 console=com1\n(XEN) Xen image load base address: 0xcf600000\n(XEN) Video information:\n(XEN)  No VGA detected\n(XEN) Disc information:\n(XEN)  Found 1 MBR signatures\n(XEN)  Found 1 EDD information structures\n(XEN) CPU Vendor: AMD, Family 22 (0x16), Model 48 (0x30), Stepping 1 (raw 00730f01)\n(XEN) Xen-e820 RAM map:\n(XEN)  [0000000000000000, 000000000009fbff] (usable)\n(XEN)  [000000000009fc00, 000000000009ffff] (reserved)\n(XEN)  [00000000000f0000, 00000000000fffff] (reserved)\n(XEN)  [0000000000100000, 00000000cfe81fff] (usable)\n(XEN)  [00000000cfe82000, 00000000cfffffff] (reserved)\n(XEN)  [00000000f8000000, 00000000fbffffff] (reserved)\n(XEN)  [00000000fed40000, 00000000fed44fff] (reserved)\n(XEN)  [0000000100000000, 000000012effffff] (usable)\n(XEN)  [000000012f000000, 000000012fffffff] (reserved)\n(XEN) ACPI: RSDP 000F3830, 0024 (r2 COREv4)\n(XEN) ACPI: XSDT CFE950E0, 0074 (r1 COREv4 COREBOOT        0 CORE 20200925)\n(XEN) ACPI: FACP CFE96E10, 0114 (r6 COREv4 COREBOOT        0 CORE 20200925)\n(XEN) ACPI: DSDT CFE95280, 1B87 (r2 COREv4 COREBOOT    10001 INTL 20200925)\n(XEN) ACPI: FACS CFE95240, 0040\n(XEN) ACPI: SSDT CFE96F30, 01EF (r2 COREv4 COREBOOT       2A CORE 20200925)\n(XEN) ACPI: MCFG CFE97120, 003C (r1 COREv4 COREBOOT        0 CORE 20200925)\n(XEN) ACPI: TPM2 CFE97160, 004C (r4 COREv4 COREBOOT        0 CORE 20200925)\n(XEN) ACPI: APIC CFE971B0, 007E (r3 COREv4 COREBOOT        0 CORE 20200925)\n(XEN) ACPI: HEST CFE97230, 01D0 (r1 COREv4 COREBOOT        0 CORE 20200925)\n(XEN) ACPI: SSDT CFE97400, 48A6 (r2 AMD    AGESA           2 MSFT  4000000)\n(XEN) ACPI: SSDT CFE9BCB0, 07C8 (r1 AMD    AGESA           1 AMD         1)\n(XEN) ACPI: DRTM CFE9C480, 007C (r1 COREv4 COREBOOT        0 CORE 20200925)\n(XEN) ACPI: HPET CFE9C500, 0038 (r1 COREv4 COREBOOT        0 CORE 20200925)\n(XEN) System RAM: 4078MB (4176004kB)\n(XEN) No NUMA configuration found\n(XEN) Faking a node at 0000000000000000-000000012f000000\n(XEN) Domain heap initialised\n(XEN) DMI present.\n(XEN) Using APIC driver default\n(XEN) ACPI: PM-Timer IO Port: 0x818 (32 bits)\n(XEN) ACPI: v5 SLEEP INFO: control[0:0], status[0:0]\n(XEN) ACPI: SLEEP INFO: pm1x_cnt[1:804,1:0], pm1x_evt[1:800,1:0]\n(XEN) ACPI: 32/64X FACS address mismatch in FADT - cfe95240/0000000000000000, using 32\n(XEN) ACPI:             wakeup_vec[cfe9524c], vec_size[20]\n(XEN) ACPI: Local APIC address 0xfee00000\n(XEN) ACPI: IOAPIC (id[0x04] address[0xfec00000] gsi_base[0])\n(XEN) IOAPIC[0]: apic_id 4, version 33, address 0xfec00000, GSI 0-23\n(XEN) ACPI: IOAPIC (id[0x05] address[0xfec20000] gsi_base[24])\n(XEN) IOAPIC[1]: apic_id 5, version 33, address 0xfec20000, GSI 24-55\n(XEN) ACPI: INT_SRC_OVR (bus 0 bus_irq 0 global_irq 2 dfl dfl)\n(XEN) ACPI: INT_SRC_OVR (bus 0 bus_irq 9 global_irq 9 low level)\n(XEN) ACPI: IRQ0 used by override.\n(XEN) ACPI: IRQ2 used by override.\n(XEN) ACPI: IRQ9 used by override.\n(XEN) Enabling APIC mode:  Flat.  Using 2 I/O APICs\n(XEN) ACPI: HPET id: 0x10228201 base: 0xfed00000\n(XEN) PCI: MCFG configuration 0: base f8000000 segment 0000 buses 00 - 3f\n(XEN) PCI: MCFG area at f8000000 reserved in E820\n(XEN) PCI: Using MCFG for segment 0000 bus 00-3f\n(XEN) HEST: Table parsing has been initialized\n(XEN) Using ACPI (MADT) for SMP configuration information\n(XEN) SMP: Allowing 4 CPUs (0 hotplug CPUs)\n(XEN) IRQ limits: 56 GSI, 776 MSI/MSI-X\n(XEN) CPU0: 1000 (600 ... 1400) MHz\n(XEN) xstate: size: 0x340 and states: 0x7\n(XEN) CPU0: AMD Fam16h machine check reporting enabled\n(XEN) Speculative mitigation facilities:\n(XEN)   Hardware hints:\n(XEN)   Hardware features:\n(XEN)   Compiled-in support: INDIRECT_THUNK SHADOW_PAGING\n(XEN)   Xen settings: BTI-Thunk RETPOLINE, SPEC_CTRL: No, Other: BRANCH_HARDEN\n(XEN)   Support for HVM VMs: RSB\n(XEN)   Support for PV VMs: RSB\n(XEN)   XPTI (64-bit PV only): Dom0 disabled, DomU disabled (without PCID)\n(XEN)   PV L1TF shadowing: Dom0 disabled, DomU disabled\n(XEN) Using scheduler: SMP Credit Scheduler rev2 (credit2)\n(XEN) Initializing Credit2 scheduler\n(XEN)  load_precision_shift: 18\n(XEN)  load_window_shift: 30\n(XEN)  underload_balance_tolerance: 0\n(XEN)  overload_balance_tolerance: -3\n(XEN)  runqueues arrangement: socket\n(XEN)  cap enforcement granularity: 10ms\n(XEN) load tracking window length 1073741824 ns\n(XEN) Platform timer is 14.318MHz HPET\n(XEN) Detected 998.136 MHz processor.\n(XEN) Freed 1024kB unused BSS memory\n(XEN) alt table ffff82d0404525b0 -&gt; ffff82d04045eaf2\n(XEN) I/O virtualisation disabled\n(XEN) nr_sockets: 1\n(XEN) ENABLING IO-APIC IRQs\n(XEN)  -&gt; Using new ACK method\n(XEN) ..TIMER: vector=0xF0 apic1=0 pin1=2 apic2=0 pin2=0\n(XEN) Allocated console ring of 32 KiB.\n(XEN) mwait-idle: does not run on family 22 model 48\n(XEN) HVM: ASIDs enabled.\n(XEN) SVM: Supported advanced features:\n(XEN)  - Nested Page Tables (NPT)\n(XEN)  - Last Branch Record (LBR) Virtualisation\n(XEN)  - Next-RIP Saved on #VMEXIT\n(XEN)  - DecodeAssists\n(XEN)  - Pause-Intercept Filter\n(XEN)  - Pause-Intercept Filter Threshold\n(XEN)  - TSC Rate MSR\n(XEN) HVM: SVM enabled\n(XEN) HVM: Hardware Assisted Paging (HAP) detected\n(XEN) HVM: HAP page sizes: 4kB, 2MB, 1GB\n(XEN) alt table ffff82d0404525b0 -&gt; ffff82d04045eaf2\n(XEN) Brought up 4 CPUs\n(XEN) Scheduling granularity: cpu, 1 CPU per sched-resource\n(XEN) Adding cpu 0 to runqueue 0\n(XEN)  First cpu on runqueue, activating\n(XEN) Adding cpu 1 to runqueue 0\n(XEN) Adding cpu 2 to runqueue 0\n(XEN) Adding cpu 3 to runqueue 0\n(XEN) MCA: Use hw thresholding to adjust polling frequency\n(XEN) mcheck_poll: Machine check polling timer started.\n(XEN) NX (Execute Disable) protection active\n(XEN) Dom0 has maximum 680 PIRQs\n(XEN) *** Building a PV Dom0 ***\n(XEN)  Xen  kernel: 64-bit, lsb\n(XEN)  Dom0 kernel: 64-bit, PAE, lsb, paddr 0x1000000 -&gt; 0x282c000\n(XEN) PHYSICAL MEMORY ARRANGEMENT:\n(XEN)  Dom0 alloc.:   0000000124000000-&gt;0000000128000000 (983076 pages to be allocated)\n(XEN) VIRTUAL MEMORY ARRANGEMENT:\n(XEN)  Loaded kernel: ffffffff81000000-&gt;ffffffff8282c000\n(XEN)  Phys-Mach map: 0000008000000000-&gt;00000080007a0120\n(XEN)  Start info:    ffffffff8282c000-&gt;ffffffff8282c4b8\n(XEN)  Page tables:   ffffffff8282d000-&gt;ffffffff82846000\n(XEN)  Boot stack:    ffffffff82846000-&gt;ffffffff82847000\n(XEN)  TOTAL:         ffffffff80000000-&gt;ffffffff82c00000\n(XEN)  ENTRY ADDRESS: ffffffff825d8180\n(XEN) Dom0 has maximum 4 VCPUs\n(XEN) Initial low memory virq threshold set at 0x4000 pages.\n(XEN) Scrubbing Free RAM in background\n(XEN) Std. Loglevel: All\n(XEN) Guest Loglevel: All\n(XEN) *** Serial input to DOM0 (type 'CTRL-a' three times to switch input)\n(XEN) Freed 632kB init memory\nmapping kernel into physical memory\nabout to get started...\n[    0.000000] Linux version 5.8.10-yocto-standard (oe-user@oe-host) (x86_64-fobnail-linux-gcc (GCC) 11.2.0, GNU ld (GNU Binutils) 2.37.2021071\n[    0.000000] Command line: root=/dev/mmcblk0p2 console=ttyS0,115200 earlyprintk=serial,ttyS0,115200\n[    0.000000] x86/fpu: Supporting XSAVE feature 0x001: 'x87 floating point registers'\n[    0.000000] x86/fpu: Supporting XSAVE feature 0x002: 'SSE registers'\n[    0.000000] x86/fpu: Supporting XSAVE feature 0x004: 'AVX registers'\n[    0.000000] x86/fpu: xstate_offset[2]:  576, xstate_sizes[2]:  256\n[    0.000000] x86/fpu: Enabled xstate features 0x7, context size is 832 bytes, using 'standard' format.\n[    0.000000] Released 0 page(s)\n[    0.000000] BIOS-provided physical RAM map:\n[    0.000000] Xen: [mem 0x0000000000000000-0x000000000009efff] usable\n[    0.000000] Xen: [mem 0x000000000009fc00-0x00000000000fffff] reserved\n[    0.000000] Xen: [mem 0x0000000000100000-0x00000000cfe81fff] usable\n[    0.000000] Xen: [mem 0x00000000cfe82000-0x00000000cfffffff] reserved\n[    0.000000] Xen: [mem 0x00000000f8000000-0x00000000fbffffff] reserved\n[    0.000000] Xen: [mem 0x00000000fec00000-0x00000000fec00fff] reserved\n[    0.000000] Xen: [mem 0x00000000fec20000-0x00000000fec20fff] reserved\n[    0.000000] Xen: [mem 0x00000000fed40000-0x00000000fed44fff] reserved\n[    0.000000] Xen: [mem 0x00000000fee00000-0x00000000feefffff] reserved\n[    0.000000] Xen: [mem 0x0000000100000000-0x000000012effffff] usable\n[    0.000000] Xen: [mem 0x000000012f000000-0x000000012fffffff] reserved\n[    0.000000] NX (Execute Disable) protection: active\n...\n</code></pre>"},{"location":"zephyr-in-dlme/","title":"Running Zephyr in DLME","text":"<p>In addition to conducting the theoretical analysis, it was decided to include a test report of one of the operating systems in order to verify the information presented. The choice fell on Zephyr.</p> <p>Running DLME requires GRUB from TrenchBoot as mainline doesn't have DLME support. Currently, there is an ongoing discussion how TrenchBoot should be integrated into Linux - see the following links:</p> <ul> <li>Discussion on adding Trenchboot secure dynamic launch Linux kernel   support.</li> <li>Discussion on adding Secure Launch SMP bringup   support.</li> </ul> <p>Unless this is solved no investment in TrenchBoot GRUB2 implementation would be made. During PoC we use GRUB from here. To reproduce PoC results please follow the instructions below.</p> <ul> <li>Clone GRUB source.</li> </ul> <pre><code>$ git clone https://github.com/3mdeb/grub/ --branch tb_xen\n</code></pre> <ul> <li>Prepare container for building GRUB.</li> </ul> <pre><code>$ cd grub\n$ docker run --rm -it -v $(readlink -f ..):$(readlink -f ..) -w $PWD ubuntu:18.04\n(docker)$ apt update\n(docker)$ apt install gcc-5 automake autoconf make git gettext autopoint \\\n    pkg-config python bison flex\n</code></pre> <ul> <li>Build GRUB (execute from container while in GRUB directory).</li> </ul> <pre><code>(docker)$ ./bootstrap\n(docker)$ mkdir ../grub-install build\n(docker)$ cd build\n(docker)$ env CC=gcc-5 CFLAGS=-Wno-error=vla ../configure --prefix=$(readlink -f ../../grub-install)\n(docker)$ make -j$(nproc)\n(docker)$ make install\n</code></pre> <ul> <li>Exit container and prepare boot disk by creating MBR + FAT32 partition</li> </ul> <pre><code>$ sudo fdisk /dev/disk/by-id/usb-TS-RDF5_SD_Transcend_000000000039-0\\:0 &lt;&lt;EOF\no\nn\np\n1\n\n\nw\nEOF\n\n$ sudo mkfs.vfat -F32 /dev/disk/by-id/usb-TS-RDF5_SD_Transcend_000000000039-0\\:0-part1\n</code></pre> <ul> <li>Install GRUB onto target device, this will put a complete GRUB into target   device, including MBR, GRUB, and its modules.</li> </ul> <pre><code>$ sudo mkdir /mnt/boot\n$ sudo mount /dev/disk/by-id/usb-TS-RDF5_SD_Transcend_000000000039-0\\:0-part1 /mnt/boot\n$ cd grub-install\n$ sudo sbin/grub-install --target=i386-pc --modules \"part_msdos fat\" \\\n    --boot-directory=/mnt/boot \\\n    /dev/disk/by-id/usb-TS-RDF5_SD_Transcend_000000000039-0\\:0\n</code></pre> <ul> <li>Build SKL (Secure Kernel Loader) from TrenchBoot and copy it to boot   partition.</li> </ul> <pre><code>$ git clone https://github.com/TrenchBoot/secure-kernel-loader\n$ cd secure-kernel-loader\n$ make\n$ cp skl.bin /mnt/boot/\n</code></pre> <p>Setup Zephyr build environment. Instructions below are based on Zephyr Getting Started Guide.</p> <ul> <li>Install required packages, Ubuntu has too old packages so we have to use   KitWare repo.</li> </ul> <pre><code>$ wget https://apt.kitware.com/kitware-archive.sh\n$ sudo bash kitware-archive.sh\n$ sudo apt install --no-install-recommends git cmake ninja-build gperf \\\n  ccache dfu-util device-tree-compiler wget \\\n  python3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\\n  make gcc gcc-multilib g++-multilib libsdl2-dev python3-venv\n$ pip3 install --user -U west\n</code></pre> <ul> <li>Obtain Zephyr toolchain.</li> </ul> <pre><code>$ wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.14.1/zephyr-sdk-0.14.1_linux-x86_64.tar.gz\n$ tar xf zephyr-sdk-0.14.1_linux-x86_64.tar.gz -C ~/.local\n$ rm zephyr-sdk-0.14.1_linux-x86_64.tar.gz\n$ ~/.local/zephyr-sdk-0.14.1/setup.sh -c\n</code></pre> <ul> <li>Fetch Zephyr source code.</li> </ul> <pre><code>$ west init zephyr\n$ cd zephyr\n$ west update\n</code></pre> <ul> <li>Install required packages, use virtual environment to avoid conflict with   user/system packages.</li> </ul> <pre><code>$ python3 -m venv .env\n$ pip3 install -r zephyr/scripts/requirements.txt\n</code></pre> <ul> <li>Build Zephyr, we use QEMU as the target, but it works on APU (without DLME).</li> </ul> <pre><code>$ cd zephyr\n$ west build -p auto -b qemu_x86_64 samples/userspace/hello_world_user/\n$ sudo cp build/zephyr/zephyr.elf /mnt/boot/\n</code></pre> <ul> <li>Configure GRUB, create '/mnt/boot/grub/grub.cfg` with the following contents.</li> </ul> <pre><code>default 0\nmenuentry \"Zephyr (DLME)\" {\n  slaunch skinit\n  slaunch_module /skl.bin\n  multiboot /zephyr.elf\n}\nmenuentry \"Zephyr (no DLME)\" {\n  multiboot /zephyr.elf\n}\n</code></pre> <ul> <li>Umount disk and sync before unplugging it. <p>There were some problems with obtaining working binary, so before booting     Zephyr on target platform please check whether it boots in QEMU (without     DLME). When booting Zephyr you should see <code>Hello World</code> message on serial     console, if Zephyr doesn't output anything or if it stuck at     <code>Booting Zephyr</code> message then something went wrong.</p> </li> </ul> <pre><code>$ qemu-system-x86_64 -nographic -serial mon:stdio -m 512M -cpu qemu64 \\\n  -drive format=raw,file=/dev/disk/by-id/usb-TS-RDF5_SD_Transcend_000000000039-0\\:0\n</code></pre> <ul> <li> <p>Zephyr should normally boot on APU, if DLME variant (from boot menu) is used   Zephyr will also boot normally - that is because TrenchBoot GRUB executes SKL   only when using   Multiboot2   but Zephyr has support only for Multiboot1.</p> </li> <li> <p>Booting Zephyr in DLME would require extending it with Multiboot2 support.</p> </li> </ul>"},{"location":"archive/charra-concept-on-pc/","title":"How to run CHARRA concept on PC","text":"<p>The detailed steps of how to build and run CHARRA applications (Attester and Verifier) are described on corresponding GitHub repository:  - build and run CHARRA on    PC, please follow    the steps listed there before running rest of this PoC</p> <p>In general there are two common ways to reach the goal:   - build docker container with binary packages   - build neccessary packages from sources inside docker container</p> <p>The first path is faster and more preferable. There are two scripts there:   - <code>docker/build.sh</code> - to build and install docker container   - <code>docker/run.sh</code> - to run docker container with installed packages for CHARRA</p> <p>When the project is built one may run and test Attester and Verifier application:</p> <ol> <li>List the docker networks:</li> </ol> <pre><code>$ docker network ls\nNETWORK ID     NAME             DRIVER    SCOPE\n....\na13b7967a1d4   `charra_default`   bridge    local\n....\n</code></pre> <ol> <li> <p>Configure network for docker in order to allow containers to communicate. E.g. edit file ./docker/run.sh and add internal virtual network to docker run command: <pre><code>--network=charra_default\n</code></pre></p> </li> <li> <p>Execute the <code>./docker.run.sh</code> script in two terminal windows</p> </li> <li> <p>Specify IP address of Attester in file <code>src/verifier.c</code> (<code>char dst_host[16]</code> in src/verifier.c) and rebuild the project in container.</p> </li> </ol> <p>Note: check IP address inside docker container <pre><code>(docker)$ cd charra\n(docker)$ make\n</code></pre></p> <ol> <li>Run Attester in one terminal</li> </ol> <pre><code>(docker)$ ./bin/attester\n10:53:23 DEBUG src/attester.c:139: [attester] Attester Configuration:\n10:53:23 DEBUG src/attester.c:140: [attester]     Used local port: 5683\n10:53:23 DEBUG src/attester.c:141: [attester]     DTLS-PSK enabled: false\n10:53:23 DEBUG src/attester.c:149: [attester]     DTLS-RPK enabled: false\n10:53:23 INFO  src/attester.c:185: [attester] Initializing CoAP in block-wise mode.\n10:53:23 INFO  src/attester.c:236: [attester] Creating CoAP server endpoint using UDP.\nFeb 21 10:53:23.959 DEBG created UDP  endpoint 0.0.0.0:5683\n10:53:23 INFO  src/attester.c:248: [attester] Registering CoAP resources.\n10:53:23 INFO  src/util/coap_util.c:192: [coap-util] Adding CoAP FETCH resource 'attest'.\n10:53:23 DEBUG src/attester.c:253: [attester] Entering main loop.\n</code></pre> <ol> <li> <p>Start Verifier in second terminal and get the result</p> </li> <li> <p>Attester output</p> </li> </ol> <pre><code>(docker)$ ./bin/attester\n11:00:50 INFO  src/attester.c:185: [attester] Initializing CoAP in block-wise mode.\n11:00:50 INFO  src/attester.c:236: [attester] Creating CoAP server endpoint using UDP.\n11:00:50 INFO  src/attester.c:248: [attester] Registering CoAP resources.\n11:00:50 INFO  src/util/coap_util.c:192: [coap-util] Adding CoAP FETCH resource 'attest'.\n11:00:54 INFO  src/attester.c:299: [attester] Resource 'attest': Received message.\n11:00:54 INFO  src/attester.c:313: [attester] Received data of length 52.\n11:00:54 INFO  src/attester.c:315: [attester] Received data of total length 52.\n11:00:54 INFO  src/attester.c:320: [attester] Parsing received CBOR data.\n11:00:54 INFO  src/attester.c:330: [attester] Preparing TPM quote data.\n11:00:54 INFO  src/attester.c:341: Received nonce of length 20:\n                                   0x00eda2a762c7b36ea0493814c98e076a45799119\n11:00:54 INFO  src/attester.c:369: [attester] Loading TPM key.\n11:00:54 INFO  src/core/charra_key_mgr.c:36: Loading key \"PK.RSA.default\".\n11:00:54 INFO  src/util/tpm2_util.c:117: Primary Key created successfully.\n11:00:54 INFO  src/attester.c:378: [attester] Do TPM Quote.\n11:00:54 INFO  src/attester.c:386: [attester] TPM Quote successful.\n11:00:54 INFO  src/attester.c:414: [attester] Preparing response.\n11:00:54 INFO  src/attester.c:438: [attester] Marshaling response to CBOR.\n11:00:54 INFO  src/attester.c:446: [attester] Size of marshaled response is 1277 bytes.\n11:00:54 INFO  src/attester.c:453: [attester] Adding marshaled data to CoAP response PDU and send it.\n</code></pre> <ul> <li>Verifier output</li> </ul> <pre><code>(docker)$ ./bin/verifier\n11:00:54 INFO  src/verifier.c:244: [verifier] Initializing CoAP in block-wise mode.\n11:00:54 INFO  src/verifier.c:252: [verifier] Registering CoAP response handler.\n11:00:54 INFO  src/verifier.c:290: [verifier] Creating CoAP client session using UDP.\n11:00:54 INFO  src/verifier.c:332: [verifier] Creating attestation request.\n11:00:54 INFO  src/verifier.c:467: [verifier] Generated nonce of length 20:\n                                                  0x00eda2a762c7b36ea0493814c98e076a45799119\n11:00:54 INFO  src/verifier.c:342: [verifier] Marshaling attestation request data to CBOR.\n11:00:54 INFO  src/verifier.c:352: [verifier] Adding CoAP option URI_PATH.\n11:00:54 INFO  src/verifier.c:360: [verifier] Adding CoAP option CONTENT_TYPE.\n11:00:54 INFO  src/verifier.c:370: [verifier] Creating request PDU.\n11:00:54 INFO  src/verifier.c:384: [verifier] Sending CoAP message.\n11:00:54 INFO  src/verifier.c:392: [verifier] Processing and waiting for response ...\n11:00:54 INFO  src/verifier.c:514: [verifier] Resource 'attest': Received message.\n11:00:54 INFO  src/verifier.c:531: [verifier] Received data of length 1277.\n11:00:54 INFO  src/verifier.c:533: [verifier] Received data of total length 1277.\n11:00:54 INFO  src/verifier.c:538: [verifier] Parsing received CBOR data.\n11:00:54 INFO  src/verifier.c:565: [verifier] Starting verification.\n11:00:54 INFO  src/verifier.c:585: [verifier] Loading TPM key.\nERROR:esys:src/tss2-esys/esys_iutil.c:389:iesys_handle_to_tpm_handle() Error: Esys invalid ESAPI handle (40000001).\nWARNING:esys:src/tss2-esys/esys_iutil.c:410:iesys_is_platform_handle() Convert handle from TPM2_RH to ESYS_TR, got: 0x40000001\n11:00:54 INFO  src/verifier.c:591: [verifier] External public key loaded.\n11:00:54 INFO  src/verifier.c:595: [verifier] Preparing TPM Quote verification.\n11:00:54 INFO  src/verifier.c:606: [verifier] Verifying TPM Quote signature with TPM ...\nERROR:esys:src/tss2-esys/esys_iutil.c:389:iesys_handle_to_tpm_handle() Error: Esys invalid ESAPI handle (40000001).\nWARNING:esys:src/tss2-esys/esys_iutil.c:410:iesys_is_platform_handle() Convert handle from TPM2_RH to ESYS_TR, got: 0x40000001\n11:00:54 INFO  src/verifier.c:612: [verifier]     =&gt; TPM Quote signature is valid!\n11:00:54 INFO  src/verifier.c:622: [verifier] Converting TPM public key to mbedTLS public key ...\n11:00:54 INFO  src/verifier.c:633: [verifier] Verifying TPM Quote signature with mbedTLS ...\n11:00:54 INFO  src/verifier.c:639: [verifier]     =&gt; TPM Quote signature is valid!\n11:00:54 INFO  src/verifier.c:660: [verifier] Verifying nonce ...\n11:00:54 INFO  src/verifier.c:665: [verifier]     =&gt; Nonce in TPM Quote is valid! (matches the one sent)\n11:00:54 INFO  src/verifier.c:678: [verifier] Verifying PCRs ...\n11:00:54 INFO  src/verifier.c:680: [verifier] Actual PCR composite digest from TPM Quote is:\n                                              0x2d5565fb483d8ea4525a7a9229677d1038ad34b6e22c8d5152e1d7f7b9817597\n11:00:54 INFO  src/core/charra_rim_mgr.c:82: Found matching PCR composite digest at index 2 of the PCR sets.\n11:00:54 INFO  src/verifier.c:691: [verifier]     =&gt; PCR composite digest is valid!\n11:00:54 INFO  src/verifier.c:743: [verifier] +----------------------------+\n11:00:54 INFO  src/verifier.c:746: [verifier] |   ATTESTATION SUCCESSFUL   |\n11:00:54 INFO  src/verifier.c:751: [verifier] +----------------------------+\n</code></pre>"},{"location":"archive/environment/","title":"Environment setup","text":"<p>This document describes how to prepare development environment for fobnail.</p>"},{"location":"archive/environment/#building-docker-container","title":"Building docker container","text":"<p>For the purpose of fobnail application development we have put necessary software into a single docker container which we called fobnail SDK. In order to build the container follow the steps below:</p> <ol> <li>Install docker using the guide    for Linux distribution present on your computer.</li> <li>Add your user to docker group: <code>sudo usermod -aG docker $USER</code>. Then log out    of the desktop session then log in again. This step is one-time only.</li> <li>Clone the fobnail SDK repository:    <pre><code>git clone https://github.com/fobnail/fobnail-sdk.git\n</code></pre></li> <li>Go to fobnail SDK directory: <code>cd fobnail-sdk</code></li> <li>Execute <code>./build.sh</code>. It will build the container with following software    available:</li> <li>Rust 1.55.0</li> <li>Cargo-embed: always the latest version available from Cargo registry</li> </ol> <p>You will need fobnail-sdk to proceed with any work. The process will take a while to build the container. If we have built the container, time to verify it. We will build a sample application from the fobnail directory using the freshly built docker container. Follow the steps below to test the container:</p> <ol> <li><code>git clone https://github.com/fobnail/nrf-hal</code></li> <li><code>cd nrf-hal</code></li> <li>Switch to <code>blinky-demo-nrf52840</code> branch: <code>git checkout blinky-demo-nrf52840</code></li> <li>Start container: <code>./run-container.sh</code></li> <li>Build a blinky application:    <pre><code>cd examples/blinky-demo-nrf52840\ncargo build --target thumbv7em-none-eabihf\n</code></pre></li> <li>At the end of the process you should see something like this:    <pre><code>Compiling blinky-demo-nrf52840 v0.1.0 (/home/build/nrf-hal/examples/blinky-demo-nrf52840)\nFinished dev [unoptimized + debuginfo] target(s) in 1m 14s\n</code></pre></li> </ol>"},{"location":"archive/local_development/","title":"Developing firmware on PC","text":"<p>Fobnail firmware can be built to run either on nRF52840 or Linux. The latter option is more suitable for development as it does not need any hardware except a development machine.</p>"},{"location":"archive/local_development/#obtaining-firmware-source-code","title":"Obtaining firmware source code","text":"<p>You can obtain source code from our GitHub repository.</p> <pre><code>$ git clone https://github.com/fobnail/fobnail --recurse-submodules\n</code></pre>"},{"location":"archive/local_development/#building-and-running-firmware-locally","title":"Building and running firmware locally","text":"<p>Make sure you have the latest Fobnail SDK installed and network setup properly. See Environment setup for instructions. For firmware to work properly you need the <code>fobnail0</code> network interface configured.</p> <p>To build and run firmware execute the following commands (from fobnail directory).</p> <pre><code>$ env FOBNAIL_LOG=trace ./build.sh -t pc --run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.60s\n     Running `target/x86_64-unknown-linux-gnu/debug/fobnail-poc`\n DEBUG fobnail &gt; UDP socket initialized\n TRACE smoltcp::socket::set &gt; [0]: adding\n</code></pre> <p>FOBNAIL_LOG environment variable sets log level. The possible log levels are: error, warning, info, debug, trace.</p> <p>When Fobnail firmware is running, <code>fobnail0</code> interface should be up.</p> <pre><code>$ ip addr show dev fobnail0\n19: fobnail0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 0a:d5:59:6a:06:77 brd ff:ff:ff:ff:ff:ff\n    inet 169.254.0.8/16 scope global fobnail0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::8d5:59ff:fe6a:677/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> <p>Note that the <code>NO-CARRIER</code> is gone now, the state has changed from <code>DOWN</code> to <code>UP</code>, and the interface has an IP address assigned. Now, you should be able to ping Fobnail and use the echo service exposed on UDP port 9400.</p> <pre><code>$ ping 169.254.0.1\n64 bytes from 169.254.0.1: icmp_seq=1 ttl=64 time=0.419 ms\n64 bytes from 169.254.0.1: icmp_seq=2 ttl=64 time=0.107 ms\n64 bytes from 169.254.0.1: icmp_seq=3 ttl=64 time=0.103 ms\n64 bytes from 169.254.0.1: icmp_seq=4 ttl=64 time=0.105 ms\n\n$ nc -u 169.254.0.1 9400\nhello\nhello\n1234567890\n1234567890\n(...)\n</code></pre>"},{"location":"archive/preparation_for_tests/","title":"Preparation for tests","text":"<p>This document describes step by step how to prepare the environment to run Fobnail and prepare it for provisioning.</p>"},{"location":"archive/preparation_for_tests/#running-fobnail-firmware","title":"Running Fobnail Firmware","text":"<ol> <li>Install docker using the guide    for Linux distribution present on your computer.</li> <li>Add your user to the docker group: <code>sudo usermod -aG docker $USER</code>. Then log     out of the desktop session then log in again. This step is one-time only.</li> <li> <p>Prepare the Fobnail environment by opening the terminal and running the     following commands:</p> <pre><code>git clone git@github.com:fobnail/fobnail.git\ncd fobnail/\ngit checkout token_provisioning\ngit submodule update --init --recursive\n</code></pre> </li> <li> <p>Put file <code>run-fobnail-sdk.sh</code> from <code>fobnail-sdk</code> repository in PATH by     running the following commands in the new terminal:</p> <pre><code>git clone git@github.com:fobnail/fobnail-sdk.git\ncd fobnail-sdk/\nmv run-fobnail-sdk.sh ~/.local/bin/\nsource ~/.bashrc\n</code></pre> </li> <li> <p>Configure Network,     for a fast but temporary solution, you can only use the first 3 commands.</p> </li> <li> <p>Put the <code>fobnail_test_root.crt</code> file in the main <code>fobnail</code> dictionary.</p> <p>You can take <code>fobnail_test_root.crt</code> from fobnail-test-environment</p> </li> <li> <p>Start Fobnail by running the following commands:</p> <pre><code>export FOBNAIL_PO_ROOT=fobnail_test_root.crt\nexport FOBNAIL_LOG=debug\n./build.sh --run\n</code></pre> </li> <li> <p>Wait for similar output:</p> <pre><code>.Finished dev [optimized + debuginfo] target(s) in 3m 21s\n    Running `target/x86_64-unknown-linux-gnu/debug/fobnail`\nINFO  fobnail &gt; Hello from main\n</code></pre> <p>If the output as above is displayed, it means that the CoAP server was successfully set up and started.</p> </li> </ol>"},{"location":"archive/preparation_for_tests/#installing-libraries-required-for-provisioning","title":"Installing libraries required for provisioning","text":"<ol> <li> <p>Install the necessary libraries by running the following command:</p> <pre><code>pip3 install cbor pem hexdump\n</code></pre> </li> <li> <p>Install the <code>libcoap</code> library by following the     procedure</p> <p>If you run into <code>git checkout</code> problems, try copying all of the content below and running it in a terminal:</p> <pre><code>git clone --recursive -b 'develop' \\\n'https://github.com/obgm/libcoap.git' /tmp/libcoap &amp;&amp; \\\ncd /tmp/libcoap &amp;&amp; \\\ngit checkout --recurse-submodules 2a329e1c763a47a910f075aad4478398aaaea400\n</code></pre> <p>libcoap3 is required, coap-client from libcoap2 will not work properly</p> </li> <li> <p>Open the terminal and run the following command to test coap-client:</p> <pre><code>coap-client -m get coap://169.254.0.1\n</code></pre> <p>If you get <code>4.04 Not found</code> output, you have installed the dependencies correctly.</p> </li> </ol> <p>The CoAp server should be running to be able to receive commands from the client. Note that provisioning token won't work when the token is already provisioned. To unprovision the token remove the <code>flash.bin</code> file from the <code>fobnail/target</code> directory.</p>"},{"location":"archive/preparation_for_tests/#testing-environment","title":"Testing environment","text":"<ol> <li> <p>Download and prepare the testing repository by opening the terminal and     running the following commands:</p> <pre><code>git clone git@github.com:fobnail/fobnail-test-environment.git\ncd fobnail-test-environment\nvirtualenv -p $(which python3) robot-venv\nsource robot-venv/bin/activate\npip install -U -r requirements.txt\n</code></pre> </li> <li> <p>Running test cases example:</p> <pre><code>robot -L TRACE -o &lt;output-file-prefix&gt; -r &lt;report_file_prefix&gt; -l &lt;output_file_name&gt;.html -v absolute_fobnail_path:&lt;path_to_fobnail&gt; tests/&lt;test_file_name&gt;.robot\n</code></pre> </li> </ol>"},{"location":"examples/disk_encryption/","title":"Use case: Disk encryption","text":""},{"location":"examples/disk_encryption/#description","title":"Description","text":"<p>Disk drive (either physical one or its image) contains personal or corporate secrets. Access to that data must be restricted to limited set of users, even if the drive itself may temporarily be made available to other parties, e.g. in transit or left unattended in semi-public space like a hotel room.</p>"},{"location":"examples/disk_encryption/#threats","title":"Threats","text":"<ul> <li>Data theft - accessing secret information contained on disk</li> <li>Installment of unauthorized data - files on disk are overwritten or new files are created</li> </ul>"},{"location":"examples/disk_encryption/#mitigations","title":"Mitigations","text":"<ul> <li>Key protection<ul> <li>Disk encryption key is off platform, it is on Fobnail Token</li> <li>Remote attestation to Fobnail is need to obtain encryption key</li> </ul> </li> <li>Platform integrity<ul> <li>Fobnail cryptographically bound to TPM</li> <li>(FUTURE FEATURE) Ability to bind one Fobnail Token to multiple platforms</li> </ul> </li> </ul>"},{"location":"examples/disk_encryption/#guide","title":"Guide","text":"<p>This guide lists steps required to use Fobnail with LUKS2-formatted disk, but other modes of encryption are also possible. It doesn't cover all features of LUKS2, this is just an example of making it work with Fobnail. More advanced usages can be found in cryptsetup FAQ, and Fobnail doesn't limit any of those.</p>"},{"location":"examples/disk_encryption/#prerequisites","title":"Prerequisites","text":"<ul> <li>Provisioned Fobnail Token</li> <li>At least one platform bound to that Token<ul> <li>(FUTURE FEATURE) May be more if same pair of disk/Token is to be used on multiple platforms</li> </ul> </li> <li>Safe environment during initial preparation of disk</li> </ul>"},{"location":"examples/disk_encryption/#steps","title":"Steps","text":"<ol> <li> <p>(Optional - when using an image instead of physical disk)</p> <pre><code>$ dd if=/dev/zero of=disk.img bs=1M count=128\n128+0 records in\n128+0 records out\n134217728 bytes (134 MB, 128 MiB) copied, 0,0718627 s, 1,9 GB/s\n$ sudo losetup -f --show disk.img\n/dev/loop5\n</code></pre> <p>Last line is the name of newly created loop device. Use it in place of  in following instructions. <li> <p>In secure environment (passed attestation) create a keyfile that will be used to decrypt master-key (see LUKS2-docs for details):</p> <pre><code>$ dd bs=512 count=4 if=/dev/urandom of=/tmp/keyfile.bin\n4+0 records in\n4+0 records out\n2048 bytes (2,0 kB, 2,0 KiB) copied, 0,00431696 s, 474 kB/s\n</code></pre> <p>You may use <code>/dev/random</code> if you're paranoid, but it may take much longer. Add <code>iflag=fullblock</code> in that case, otherwise key could be truncated.</p> <p>Make sure the environment is kept secure (e.g. don't leave the platform unattended) until further notice.</p> </li> <li> <p>Initialize LUKS partition on the disk:</p> <pre><code>$ sudo cryptsetup luksFormat --type luks2 /dev/&lt;your_disk&gt; keyfile.bin\n</code></pre> <p>Despite <code>format</code> in its name, this command does not format the disk, but it still destroys the data on it. This will be reiterated by above command and you have to explicitly confirm it.</p> </li> <li> <p>Map the LUKS2 container and create a file system on it:</p> <pre><code>$ sudo cryptsetup luksOpen -d /tmp/keyfile.bin /dev/&lt;your_disk&gt; c1\n$ sudo mke2fs -j /dev/mapper/c1\n</code></pre> <p><code>c1</code> is the name of the mapping. It can be any other unused name. Another filesystems can also be used.</p> </li> <li> <p>(Optional) Mount the partition and copy data to it:</p> <pre><code>$ sudo mount /dev/mapper/c1 /mnt\n$ sudo cp top_secret_file.pdf /mnt/\n$ sudo umount /mnt\n</code></pre> <p>It may be beneficial to call <code>sudo chown -R $USER:$USER /mnt</code> while the partition is mounted so accessing files would be possible as non-root user.</p> </li> <li> <p>Close LUKS2 container:</p> <pre><code>$ sudo cryptsetup close c1\n</code></pre> </li> <li> <p>Move key to Fobnail Token:</p> <pre><code>$ sudo fobnail-attester --write-file /tmp/keyfile.bin:luks_key &amp;&amp; \\\n  dd if=/dev/urandom of=/tmp/keyfile.bin bs=$(stat -c %s /tmp/keyfile.bin) count=1 &amp;&amp; \\\n  rm /tmp/keyfile.bin\n</code></pre> <p><code>luks_key</code> is name under which file is saved on Fobnail Token. It can be arbitrary, as long as it doesn't contain any of the forbidden characters listed here.</p> <p>DO NOT overwrite or remove <code>keyfile.bin</code> unless it was successfully written to the Token or you won't be able to access the disk.</p> </li> <li> <p>(Optional - when using an image instead of physical disk)</p> <pre><code>$ sudo losetup -d /dev/&lt;your_disk&gt;\n</code></pre> </li> <li> <p>At this point the keyfile should be present only in Fobnail Token. Platform no longer has to be maintained in secure state.</p> </li> <li> <p>When access to the drive is required, plug in Token and disk and run:</p> <p>(Optional - when using image file) Repeat <code>sudo losetup -f --show disk.img</code>. Note that the device number may be different than previously.</p> <pre><code>$ sudo fobnail-attester --read-file luks_key:- | \\\n  sudo cryptsetup luksOpen -d - /dev/&lt;your_disk&gt; c1\n$ sudo mount /dev/mapper/c1\n</code></pre> <p>The same name as in step 7 must be used for reading, <code>luks_key</code> in this case. <code>-</code> in place of output filename tells to read to stdout, which is passed through a pipe to <code>cryptsetup</code>. This way the key isn't saved to disk.</p> </li> <li> <p>Use drive as usual.</p> <p>Note that it will be accessible until the mapping is closed, regardless of Fobnail Token's presence or current platform state. Only guarantee is that at the time of requesting the keyfile attestation finished successfully.</p> </li> <li> <p>When done, unmount and close the disk:</p> <pre><code>$ sudo umount /mnt\n$ sudo cryptsetup close c1\n</code></pre> </li> <li> <p>(Optional - when using an image instead of physical disk)</p> <pre><code>$ losetup -d /dev/&lt;your_disk&gt;\n</code></pre> </li>"}]}